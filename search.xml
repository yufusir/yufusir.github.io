<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>blog的搭建</title>
      <link href="/posts/d6cdeee.html"/>
      <url>/posts/d6cdeee.html</url>
      
        <content type="html"><![CDATA[<h3 id="利用Hexo搭建blog"><a href="#利用Hexo搭建blog" class="headerlink" title="利用Hexo搭建blog"></a>利用Hexo搭建blog</h3><p>这篇文章只是用来记录我搭建blog的过程的，虽然我这次布置的有些小小拉跨，但是对于我自己的使用是十分足够的，使用hexo布置blog在GitHub上基本免费的（有钱就别用这种搭建，费时费力），我可能会在之后的时间里对这个网站优化。总体而言，有个独属于自己的博客在感觉上还是不错的。如果也有人想用hexo搭建blog，我会把教程与资料分享在下面，欢迎大家与我互换友链</p><h4 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h4><p>b站安知鱼有一套完整的教程<a href="https://www.bilibili.com/video/BV13v4y1c75G/?spm_id_from=333.788&amp;vd_source=d7aed904328df9600c4d6478e2ce67b8">01.hexo博客搭建最终效果展示_哔哩哔哩_bilibili</a></p><h4 id="中途需要的资源网站与文章"><a href="#中途需要的资源网站与文章" class="headerlink" title="中途需要的资源网站与文章"></a>中途需要的资源网站与文章</h4><p>hexo的安装<a href="https://blog.anheyu.com/posts/ddae.html">使用 Github Pages 和 Hexo 搭建自己的独立博客 | 安知鱼 (anheyu.com)</a></p><p>butterfly的安装<a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安裝文檔(一) 快速開始 | Butterfly</a></p><p>butterfly的配置<a href="https://blog.anheyu.com/posts/sdxhu.html">butterfly 重装日记 | 安知鱼 (anheyu.com)</a></p><p>node的官网<a href="https://nodejs.org/en/download/prebuilt-installer">Node.js — Download Node.js® (nodejs.org)</a></p><p>git的官网<a href="https://git-scm.com/download/win">Git - Downloading Package (git-scm.com)</a></p><p>免费图床<a href="https://www.superbed.cn/signup?from_id=127373">https://www.superbed.cn/signup?from_id=127373</a></p><p>注意：有部分软件在国外，所以魔法必要，但如果你的魔法不太行，可以到清华镜像里面找找</p><h4 id="hexo操作"><a href="#hexo操作" class="headerlink" title="hexo操作"></a>hexo操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">清除缓存</span><br><span class="line">hexo cl</span><br><span class="line"></span><br><span class="line">保存</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">本地运行</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">上传github</span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line">更新动漫数据</span><br><span class="line">hexo bangumi -u</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑马程序员python自学笔记，超详细（内置环境配置与编译器的下载）</title>
      <link href="/posts/c0de5885.html"/>
      <url>/posts/c0de5885.html</url>
      
        <content type="html"><![CDATA[<h3 id="Python的学习"><a href="#Python的学习" class="headerlink" title="Python的学习"></a>Python的学习</h3><h4 id="环境的搭建"><a href="#环境的搭建" class="headerlink" title="环境的搭建"></a>环境的搭建</h4><p>请参考以下文章</p><p><a href="https://blog.csdn.net/Xuange_Aha/article/details/128615437?ops_request_misc=%7B%22request%5Fid%22%3A%22171791844516777224416555%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171791844516777224416555&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-4-128615437-null-null.142^v100^pc_search_result_base8&amp;utm_term=python环境配置&amp;spm=1018.2226.3001.4187">Python：环境变量配置方法 详细教程_python环境变量的配置-CSDN博客</a></p><h4 id="编译器的下载"><a href="#编译器的下载" class="headerlink" title="编译器的下载"></a>编译器的下载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.jetbrains.com.cn/en-us/pycharm/</span><br></pre></td></tr></table></figure><h4 id="HelloWorld案例的实现"><a href="#HelloWorld案例的实现" class="headerlink" title="HelloWorld案例的实现"></a>HelloWorld案例的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;HelloWorld&quot;)</span><br></pre></td></tr></table></figure><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print()输出括号的内容之后默认回车，变量与变量之间用逗号隔开</span><br><span class="line">input(提示信息)显示提示信息（可有可无），接收键盘的输入，获得的内容默认转换为字符串</span><br></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#为单行注释</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;为多行注释</span><br></pre></td></tr></table></figure><p>变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">概述：</span><br><span class="line">能够储存计算结果的或能表示值的抽象概念，变量没有数据类型，可以存储任意数据</span><br></pre></td></tr></table></figure><h4 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h4><p>概述：判断数据类型</p><h4 id="常见的转换语句"><a href="#常见的转换语句" class="headerlink" title="常见的转换语句"></a>常见的转换语句</h4><div class="table-container"><table><thead><tr><th>语句（函数）</th><th>说明</th></tr></thead><tbody><tr><td>int(x)</td><td>将x转换为一个整数</td></tr><tr><td>float(x)</td><td>将x转换为一个浮点数</td></tr><tr><td>str(x)</td><td>将对象x转换为字符串</td></tr></tbody></table></div><h4 id="字符串的拼接与格式化"><a href="#字符串的拼接与格式化" class="headerlink" title="字符串的拼接与格式化"></a>字符串的拼接与格式化</h4><p>拼接：</p><p>使用“+”号连接字符串变量或者字符串字面量，但是无法与非字符串类型进行拼接</p><p>格式化：</p><ul><li>“%占位符”%变量</li><li>f“{变量}  {变量}” </li></ul><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">if型：</span><br><span class="line"></span><br><span class="line">if 要判断的条件：</span><br><span class="line">条件成立时，要做的事</span><br><span class="line">#注意，用缩进表示归属于的代码块</span><br><span class="line"></span><br><span class="line">if else型：</span><br><span class="line"></span><br><span class="line">if 要判断的条件：</span><br><span class="line">条件成立时，要做的事</span><br><span class="line">else：</span><br><span class="line">条件不成立及要做的事</span><br><span class="line"></span><br><span class="line">if elif else型：</span><br><span class="line"></span><br><span class="line">if 要判断的条件：</span><br><span class="line">条件成立时，要做的事</span><br><span class="line">elif 要判断的条件：</span><br><span class="line">条件成立及要做的事</span><br><span class="line">else：</span><br><span class="line">条件不成立要做的事</span><br></pre></td></tr></table></figure><h4 id="随机数的产生"><a href="#随机数的产生" class="headerlink" title="随机数的产生"></a>随机数的产生</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">num = random.randint(a,b)</span><br></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while 条件：</span><br><span class="line">条件满足时，做的事情</span><br></pre></td></tr></table></figure><h4 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h4><p>注意用缩进表示层次关系就行</p><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">for 临时变量 in 待处理数据集（序列）：</span><br><span class="line">循环执行代码</span><br></pre></td></tr></table></figure><p>注意：他会将序列的元素一个一个放入临时变量里在代码区处理，直到所有的元素都处理才停止</p><h4 id="循环中断与停止"><a href="#循环中断与停止" class="headerlink" title="循环中断与停止"></a>循环中断与停止</h4><ul><li>continue：中断循环，直接进入下一次</li><li>break：结束循环</li></ul><h4 id="range语句"><a href="#range语句" class="headerlink" title="range语句"></a>range语句</h4><p>功能：</p><p>获得一个数字序列</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">range(num)#从0开始到num结束（不含有num本身），步长默认为1</span><br><span class="line">range(num1,num2)#从num1到num2结束（不含有num2本身），步长默认为1</span><br><span class="line">range(num1,num2,step)#从num1到num2结束（不含有num2本身），步长为step</span><br></pre></td></tr></table></figure><p>range用途很多，多数用在for循环场景</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>概述：</p><p>组织好的，可重复使用的，用来实现特定功能的代码段</p><p>定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def 函数名（传入参数）：</span><br><span class="line">函数体</span><br><span class="line">return 返回值</span><br></pre></td></tr></table></figure><h4 id="lambda匿名函数"><a href="#lambda匿名函数" class="headerlink" title="lambda匿名函数"></a>lambda匿名函数</h4><p>概述：无名称的函数，只可临时使用一次</p><p>定义：    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lambda 传入参数：函数体（一行代码）</span><br><span class="line">注意：只能写一行代码，无法写多行代码</span><br></pre></td></tr></table></figure><h4 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def test_return():</span><br><span class="line">return 1,2</span><br><span class="line"></span><br><span class="line">x,y = test_return()</span><br><span class="line">print(x) #结果1</span><br><span class="line">print(y) #结果2</span><br><span class="line"></span><br><span class="line">按照返回的顺序，写对应顺序的多个变量接受即可</span><br><span class="line">变量之间用逗号隔开</span><br><span class="line">支持不同类型的数据return</span><br></pre></td></tr></table></figure><h4 id="多个传参方式"><a href="#多个传参方式" class="headerlink" title="多个传参方式"></a>多个传参方式</h4><ul><li><p>位置传参：根据参数位置来传递参数</p></li><li><p>关键字传参：通过”键=值“形式传递参数，没有顺序要求</p></li><li><p>缺省参数：缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值</p></li><li><p>不定长参数：也叫可变参数，用于不确定调用的时候会传递多少个参数（不传参也可以）</p><ul><li><p>位置传递</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def user_info(*arge):</span><br><span class="line">print(arge)</span><br><span class="line"></span><br><span class="line">#(&#x27;TOM&#x27;)</span><br><span class="line">user_info(&#x27;TOM&#x27;)</span><br><span class="line">#(&#x27;TOM&#x27;,&#x27;18&#x27;)</span><br><span class="line">user_info(&#x27;TOM&#x27;,18)</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">传进的所有参数都会被args变量收集，他会根据传进参数的位置合并为一个元组（tuple），args是元组类型，这就是元组类型，这就是元组类型，这就是位置传递</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>关键字传递</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def user_info(**kargs):</span><br><span class="line">print(kwargs)</span><br><span class="line"></span><br><span class="line">#&#123;&#x27;name&#x27;;&#x27;TOM&#x27;,&#x27;age&#x27;;18,&#x27;id&#x27;:110&#125;</span><br><span class="line">user_info(name=&#x27;TOM&#x27;,age=18,id=110)</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">参数是”键=值“形式的形式的情况下，所有的”键=值“都会被kwargs接受，同时会根据”键=值“组成字典</span><br></pre></td></tr></table></figure></li></ul><p>注意：</p><ul><li>位置参数必须出现在其他参数前面，包括函数定义和调用</li></ul><h4 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def test_func(compute):</span><br><span class="line">result = compute(1,2)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">def compute(x,y):</span><br><span class="line">return x+y</span><br><span class="line"></span><br><span class="line">test_func(compute) #结果：3</span><br></pre></td></tr></table></figure><p>这是一种计算逻辑的传递，而非数据的传递，就像上述代码那样，不仅仅是相加，相减，相除，等任何逻辑都可以自行定义并作为函数传入</p><h4 id="None"><a href="#None" class="headerlink" title="None"></a>None</h4><p>概述：</p><p>None是类型‘NoneType’的字面量，用于表示：空的，无意义的</p><p>函数不是用return就会默认返回None</p><h4 id="说明文档"><a href="#说明文档" class="headerlink" title="说明文档"></a>说明文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">param x: 参数x的说明</span><br><span class="line">param y: 参数y的说明</span><br><span class="line">return:  返回值的说明</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h4 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h4><p>变量注解</p><ul><li>语法一：变量：类型</li><li>语法二：在注释中，#type：类型</li></ul><p>函数注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def 函数方法名(形参：类型，……，形参：类型) -&gt; 返回值类型：</span><br><span class="line">pass</span><br></pre></td></tr></table></figure><p>注意，返回值类型注解的符号使用：-&gt;</p><p>Union注解（联合类型注解）：</p><ul><li>导包：from typing import Union</li><li>使用：Union[类型，……，类型]</li></ul><h4 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h4><p>局部变量：</p><p>定义在函数内部，外部无法使用</p><p>全局变量：</p><p>定义在函数外面，函数内外都可以使用，定义在函数内部的变量可以通过global关键字声明为全局变量</p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>在程序中是可以做到和生活中那样，设计表格，生产表格，填写表格的组织形式的</p><p>1.在程序中设计表格，我们称为：设计类（class）</p><p>2.在程序中打印生产表格，我们称之为：创建对象</p><p>3.在程序中填写表格，我们称之为：对象属性赋值</p><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>1.类是由哪两部分组成呢？</p><ul><li><p>类的属性，称之为：成员变量</p></li><li><p>类的行为，称之为：成员方法</p><p>注意：函数是写在类外的，定义在类内部，我们都称之为方法</p></li></ul><p>2.类和成员方法的定义语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class 类名称:</span><br><span class="line">成员变量</span><br><span class="line"></span><br><span class="line">def 成员方法(self,参数列表):</span><br><span class="line">成员方法体</span><br><span class="line"></span><br><span class="line">对象 = 类名称()</span><br></pre></td></tr></table></figure><p>3.self的作用</p><ul><li>表示类对象本身的意思</li><li>只有通过self，成员方法才能访问类的成员变量</li><li>self出现在形参列表中，但是不占用参数位置，无需理会</li></ul><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><p>1.现实世界的事物由什么组成？</p><ul><li>属性</li><li>行为</li></ul><p>类也可以包含属性和行为，所以使用类描述现实世界事物非常合适的</p><p>2.类和对象的关系是什么？</p><ul><li>类是程序中的“设计图纸”</li><li>对象是基于图纸生产的具体实体</li></ul><p>3.什么是面向对象编程？</p><p>面向对象编程就是，使用对象进行编程。</p><p>即，设计类，基于类创建对象，并使用对象来完成具体的工作</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>Python类可以使用：<em> init </em> ()方法，称之为构造方法。</p><p>可以实现：</p><ul><li>在创建对象（构造类）的时候，会自动执行。</li><li>在创建类对象（构造类）的时候，将传入的参数自动传递给<em> init </em>方法使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class student:</span><br><span class="line">name = None</span><br><span class="line">age = None     这些可以不写</span><br><span class="line">tel = Nome</span><br><span class="line"></span><br><span class="line">def _init_(self,name.age.tel):</span><br><span class="line">self.name = name</span><br><span class="line">self.age = age</span><br><span class="line">self.tel = tel</span><br><span class="line">print(&quot;student类创建了一个对象&quot;)</span><br></pre></td></tr></table></figure><h4 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h4><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td><em> init </em></td><td>构造方法，可用于创建类对象的时候设置初始化行为</td></tr><tr><td><em> str </em></td><td>用于实现类对象转字符的行为</td></tr><tr><td><em> lt </em></td><td>用于两个类对象进行小于或大于比较</td></tr><tr><td><em> le </em></td><td>用于两个类进行小于等于或大于等于比较</td></tr><tr><td><em> eq </em></td><td>用于两个类进行相等比较</td></tr></tbody></table></div><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>1.封装的概念是指？</p><p>将现实世界事物在类中描述为属性和方法，即为封装。</p><p>2.什么是私有成员？为什么需要私有成员？</p><p>现实事物有部分属性和行为是不公开对使用者开放的。同样在类的描述属性和方法的时候也需要到达这个要求，就需要定义私有成员了</p><p>3.如何定义私有成员？</p><p>成员变量和成员方法的命名均以 __ 作为开头即可</p><p>4.私有成员的访问限制？</p><ul><li>类对象无法访问私有成员</li><li>类中的其他成员可以访问私有成员</li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>什么是继承？</p><p>继承就是一个类，继承另外一个类的成员变量和成员方法</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class 类(父类1,父类2,父类3,...,父类n):</span><br><span class="line">类内容体</span><br></pre></td></tr></table></figure><p>子类构建的类对象，可以</p><ul><li>有自己的成员变量，和成员方法</li><li>使用父类的成员变量和成员方法</li></ul><p>2.单继承和多继承</p><p>单继承：一个类继承另一个类</p><p>多继承：一个类继承多个类，按照顺序从左向右依次继承</p><p>多继承中，如果父类有同名方法或属性，先继承的优先级高于后继承</p><p>3.pass关键之的作用是什么</p><p>pass是占位语句，用来保证函数（方法 ）或类定义的完整，表示无内容，空的意思</p><h4 id="复写"><a href="#复写" class="headerlink" title="复写"></a>复写</h4><p>1.复写表示：</p><p>对父类的成员属性或者成员方法进行重新定义</p><p>2.复写的语法：</p><p>在子类中重新实现同名成员方法或成员属性即可</p><p>3.在子类中，如何调用父类成员</p><p>方法一：</p><ul><li><p>调用父类成员</p><p>使用成员变量：父类名.成员变量</p><p>使用成员方法：父类名.成员方法(self)</p></li></ul><p>方法2：</p><ul><li><p>使用super()调用父类成员变量</p><p>使用成员变量：super().成员变量</p><p>使用成员方法：super().成员方法()</p></li></ul><p>注意：只能可以在子类内部调用父类的同名成员，子类的实体类对象调用默认是调用子类复写的</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>1.什么是多态？</p><p>多态指的是，同一个行为的不同对象获得不同的状态。</p><p>如，定一个函数（方法），通过类型注释声明需要父类对象，实际传入子类对象进行工作，从而获得不同的工作状态 </p><p>2.什么是抽象类（接口的）</p><p>包含抽象方法的类，称之为抽象类。抽象方法是指：没有具体实现的方法（pass）称之为抽象方法</p><p>3.抽象类的作用</p><p>多用于做顶层设计（设计标准），一边子类做具体实现。</p><p>也是对子类的一种软性约束，要求子类必须复写（实现）父类的一些方法，并配合多态使用，获得不同的工作状态。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>1.什么是闭包？</p><p>定义双重函数，内层嵌套可以访问外层函数的变量，将内存函数作为外层函数的返回，此内层函数就是闭包函数</p><p>2.闭包的好处和缺点？</p><ul><li>优点：不定义全局变量，也可以让函数持续访问和修改一个外部变量</li><li>优点：闭包函数引用的外部变量，是外层函数的内部变量。作用域封闭难以被误操作修改</li><li>缺点：额外的内存占用</li></ul><p>3.nonlocal关键字的作用</p><p>在闭包函数（内部函数中）想要修改外部变量的变量值，需要用nonlocal声明这个外部变量</p><h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><p>1.什么是装饰器？</p><p>装饰器就是使用一个闭包函数，在闭包函数内调用目标函数。可以达到不改动目标函数的同时。增加额外的功能。</p><p>2.装饰器的写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def outer(func):</span><br><span class="line">def inner();</span><br><span class="line">print(&quot;我要睡觉了&quot;)</span><br><span class="line">func()</span><br><span class="line">print(&quot;我要起床了&quot;)</span><br><span class="line">return inner</span><br><span class="line">    </span><br><span class="line">@outer</span><br><span class="line">def sleep():</span><br><span class="line">import random</span><br><span class="line">import time</span><br><span class="line">print(&quot;睡眠中……&quot;)</span><br><span class="line">time.sleep(random.randint(1,5))</span><br><span class="line">sleep()</span><br></pre></td></tr></table></figure><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p>1.什么是设计模式</p><p>设计模式就是一种编程套路。使用特定的套路得到特定的效果</p><p>2.什么是单例设计模式</p><p>单例模式就是对一个类，只获取其唯一的类实例对象，维持复用它。</p><ul><li>节省空间</li><li>节省创建对象的开销</li></ul><p>3.什么是工厂模式</p><p>将对象的创建由使用原生类本身创造，转换到由特定的工厂方法来创造</p><p>4.好处</p><ul><li>大批量创建对象的时候有统一的入口方法，易于代码维护</li><li>当发生修改，仅修改工厂类的创建方法即可</li><li>符合现实世界模式，即由工厂来制作产品（对象）</li></ul><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>1.什么是进程</p><p>程序在操作系统内运行，即成为一个运行进程</p><p>2.什么是线程</p><p>进程内部可以有多个线程，程序的运行本质上就是由进程内部的线程在实际工作的</p><p>3.什么是并行执行</p><ul><li>多个线程同时在运行，即不同的程序同时运行，称之为：多任务并行执行</li><li>一个进程内多个线程同时在运行，称之为：多线程并行执行</li></ul><p>threading模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">thread_obj = threading.Thread([group [,targer [, name [, args [,kwargs]]]])</span><br><span class="line">- group:暂时无用，未来功能的预留参数</span><br><span class="line">- target:执行目标任务名</span><br><span class="line">- args:以元组的方式给执行任务传参</span><br><span class="line">- kwargs:以字典方式给执行任务传参</span><br><span class="line">- neme:线程名，一般不用设置</span><br><span class="line">#启动线程，让线程开始工作</span><br><span class="line">thread_obj.start()</span><br><span class="line">#创建线程对象</span><br><span class="line">thread_obj = threading.Thread(target=func)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>1.数据库是什么？有什么作用呢？</p><p>数据库就是指数据存储的库，作用就是组织数据并存储数据。</p><p>2.数据库如何组织数据呢？</p><p>按照：库-&gt;表-&gt;数据 三个层级进行组织</p><p>3.数据库软件是什么？我们学习哪种数据库软件呢？</p><p>数据库软件就是提供库-&gt;表-&gt;数据,这种数据组织形式的工具软件，也是称之为数据库管理系统</p><p>常见的数据库软件由：Oracle，MySQL，SQL Server，PostgreSQL，SQLite</p><p>4.数据库和SQL的关系是？</p><p>数据库（软件）提供数据组织储存的能力</p><p>SQL语句则是操作数据，数据库的工具语言</p><h4 id="数据容器"><a href="#数据容器" class="headerlink" title="数据容器"></a>数据容器</h4><p>概述：</p><p>一种可以存储多个元素的python数据类型</p><p>常见的有list（列表），tuple（元组），str（字符串），set（集合），dict（字典）</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h4 id="基本格式："><a href="#基本格式：" class="headerlink" title="基本格式："></a>基本格式：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#字面量</span><br><span class="line">[元素1，元素2，元素3，...]</span><br><span class="line"></span><br><span class="line">#定义变量</span><br><span class="line">变量名称 = [元素1，元素2，元素3，...]</span><br><span class="line"></span><br><span class="line">#定义空列表</span><br><span class="line">变量名称 = []</span><br><span class="line">变量名称 = list[]</span><br></pre></td></tr></table></figure><h4 id="索引："><a href="#索引：" class="headerlink" title="索引："></a>索引：</h4><p>每个元素都有编号，被称为下标索引</p><ul><li>从前到后的方向，编号从0开始递增</li><li>从后向前的方向，编号从-1开始递减</li></ul><h4 id="列表的方法"><a href="#列表的方法" class="headerlink" title="列表的方法"></a>列表的方法</h4><div class="table-container"><table><thead><tr><th>使用方式</th><th>说明</th></tr></thead><tbody><tr><td>列表.append（元素）</td><td>向列表中追加一个元素</td></tr><tr><td>列表.extend（容器）</td><td>将数据容器的内容依次取出，追加到列表尾部</td></tr><tr><td>列表.insert（下标，元素）</td><td>在指定下标处，插入指定的元素</td></tr><tr><td>del 列表[下标]</td><td>删除列表指定下标元素</td></tr><tr><td>列表.pop(下标)</td><td>删除列表指定下标元素</td></tr><tr><td>列表.remove(元素)</td><td>从前向后，删除此元素第一个匹配项</td></tr><tr><td>列表.clear()</td><td>清空列表</td></tr><tr><td>列表.count(元素)</td><td>统计此元素在列表中出现的次数</td></tr><tr><td>列表.index(元素)</td><td>查找指定元素在列表的下标（找不到会报错ValueError）</td></tr><tr><td>len(列表)</td><td>统计容器内有多少元素</td></tr></tbody></table></div><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>可以容纳不容类型的元素（混装）</li><li>数据是有序的（有下标序号）</li><li>允许数据重复</li></ul><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><h4 id="基本格式：-1"><a href="#基本格式：-1" class="headerlink" title="基本格式："></a>基本格式：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#定义元组字面量</span><br><span class="line">(元素，元素，....)</span><br><span class="line"></span><br><span class="line">#定义元组变量</span><br><span class="line">变量名称 = (元素，元素，....)</span><br><span class="line"></span><br><span class="line">#定义空元组</span><br><span class="line">变量名称 = ()</span><br><span class="line">变量名称 = tuple()</span><br></pre></td></tr></table></figure><h4 id="元组的方法"><a href="#元组的方法" class="headerlink" title="元组的方法"></a>元组的方法</h4><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>index()</td><td>查找指定元素在元组的下标（找不到会报错ValueError）</td></tr><tr><td>count()</td><td>统计此元素在元组中出现的次数</td></tr><tr><td>len(元组)</td><td>统计容器内有多少元素</td></tr></tbody></table></div><h4 id="元组的特点"><a href="#元组的特点" class="headerlink" title="元组的特点"></a>元组的特点</h4><p>多数特性与列表一致，不同点在于元组具有不可以修改的特性</p><h3 id="str"><a href="#str" class="headerlink" title="str"></a>str</h3><h4 id="索引：-1"><a href="#索引：-1" class="headerlink" title="索引："></a>索引：</h4><ul><li>从前到后的方向，编号从0开始递增</li><li>从后向前的方向，编号从-1开始递减</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#通过下标获取特定位置字符</span><br><span class="line">name = &quot;helloworld&quot;</span><br><span class="line">print(name[0]) #结果为h</span><br><span class="line">print(name[-1])#结果为d</span><br></pre></td></tr></table></figure><h4 id="字符串的替换"><a href="#字符串的替换" class="headerlink" title="字符串的替换"></a>字符串的替换</h4><p>语法：字符串.replace(字符串1，字符串2)</p><p>功能：将字符串内的全部内容：字符串1，替换为字符串2，返回一个新的字符串</p><h4 id="字符串的分割"><a href="#字符串的分割" class="headerlink" title="字符串的分割"></a>字符串的分割</h4><p>语法：字符串.split(分隔符字符串)</p><p>功能：按照指定的分隔符字符串，将字符串划分为多个字符串，并返回一个列表对象</p><h4 id="规整操作"><a href="#规整操作" class="headerlink" title="规整操作"></a>规整操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：字符串.strip()    #去除前后的空格</span><br><span class="line">语法：字符串.strip(字符串1) #去除前后指定字符串1中字符</span><br></pre></td></tr></table></figure><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>只存储字符串</li><li>不可修改</li></ul><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>内容有序，可以使用下标索引的一类数据容器，列表，元组，字符串，均可以视为序列</p><h4 id="切片："><a href="#切片：" class="headerlink" title="切片："></a>切片：</h4><p>语法：序列[起始：结束：步长]</p><ul><li>起始可以省略，省略从头开始</li><li>结束可以省略，省略到尾结束</li><li>步长可以省略，省略步长为1（可以为负数，表示倒叙执行）</li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h4 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#定义集合字面量</span><br><span class="line">&#123;元素，元素，……&#125;</span><br><span class="line">#定义集合变量</span><br><span class="line">变量名称 = &#123;元素，元素，……&#125;</span><br><span class="line">#定义空集合</span><br><span class="line">变量名称 = set()</span><br></pre></td></tr></table></figure><h4 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h4><div class="table-container"><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>集合.add(元素)</td><td>集合内添加一个元素</td></tr><tr><td>集合.remove(元素)</td><td>移除集合内指定元素</td></tr><tr><td>集合.pop()</td><td>从集合中随机取出一个元素</td></tr><tr><td>集合.clear()</td><td>将集合清空</td></tr><tr><td>集合1.difference(集合2)</td><td>得到一个新集合，内含2个集合的差集，原有的2个集合内容不变</td></tr><tr><td>集合1,difference_updata(集合2)</td><td>在集合1中，删除集合2中存在的元素，集合1被修改，集合2不变</td></tr><tr><td>集合1.union(集合2)</td><td>得到1个新集合，内含2个集合的全部元素，原有的2个集合内容不变</td></tr><tr><td>len(集合)</td><td>得到一个整数，记录集合的元素数量</td></tr></tbody></table></div><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul><li>可以容纳不同的数据类型（混装）</li><li>数据是无序存储的</li><li>没有重复数据</li><li>可以增加删除元素</li><li>支持for循环</li></ul><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><h4 id="基本格式：-2"><a href="#基本格式：-2" class="headerlink" title="基本格式："></a>基本格式：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#字典存储的是键值对</span><br><span class="line">#定义字典字面量</span><br><span class="line">&#123;key:value,key:value,……&#125;</span><br><span class="line">#定义字典变量</span><br><span class="line">my_dict = &#123;key:value,key:value,……&#125;</span><br><span class="line">#定义空字典</span><br><span class="line">my_dict = &#123;&#125;</span><br><span class="line">my_dict = dict()</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>键值对的Key和Value可以是任意类型（key不可以为字典）</li><li>字典内的Key不能重复，重复添加等于覆盖原有数据</li><li>字典没有下标索引，但可以通过key索检value</li></ul><h4 id="常用功能-1"><a href="#常用功能-1" class="headerlink" title="常用功能"></a>常用功能</h4><div class="table-container"><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>字典[key]</td><td>获取指定key对应的value值</td></tr><tr><td>字典[key]=value</td><td>添加或更新键值对</td></tr><tr><td>字典.pop(key)</td><td>取出key对应的value并在字典内删除此key的键值对</td></tr><tr><td>字典.clear()</td><td>清空字典</td></tr><tr><td>字典.keys()</td><td>获取字典的全部key，可用于for循环遍历字典</td></tr><tr><td>len(字典)</td><td>计算字典内的元素数量</td></tr></tbody></table></div><h3 id="容器的通用功能"><a href="#容器的通用功能" class="headerlink" title="容器的通用功能"></a>容器的通用功能</h3><div class="table-container"><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>通用for循环</td><td>遍历容器（字典是遍历Key）</td></tr><tr><td>max()</td><td>容器内最大的元素</td></tr><tr><td>min()</td><td>容器内最小的元素</td></tr><tr><td>len()</td><td>容器元素的个数</td></tr><tr><td>list()</td><td>转换为列表</td></tr><tr><td>tuple()</td><td>转换为元组</td></tr><tr><td>str()</td><td>转换为字符串</td></tr><tr><td>set()</td><td>转换为集合</td></tr><tr><td>sorted(序列，[reverse=True])</td><td>排序，reverse=True表示降序得到一个排好序的列表</td></tr></tbody></table></div><h4 id="列表的sort方法"><a href="#列表的sort方法" class="headerlink" title="列表的sort方法"></a>列表的sort方法</h4><p>使用方法：</p><p>列表.sort(key=选择排序依据的函数，reverse=True|False)</p><ul><li>参数key，要求传入一个函数，表示将列表的每一个元素都传入函数中，返回排列的依据</li><li>参数reverse，是否反转排序结果，True表示降序，False表示升序</li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><h4 id="open-打开函数"><a href="#open-打开函数" class="headerlink" title="open()打开函数"></a>open()打开函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">open(name,mode,encoding)</span><br><span class="line">name:文件名或文件路径</span><br><span class="line">mode:访问模式</span><br><span class="line">encoding：编码格式（推荐使用UTF-8）</span><br><span class="line">示例代码：</span><br><span class="line">f=open(&#x27;python.txt&#x27;,&#x27;r&#x27;,encoding=&#x27;UTF-8&#x27;)</span><br><span class="line">#encoding的顺序不是第三位，所以不能用位置参数，用关键字参数直接指定</span><br></pre></td></tr></table></figure><p>访问模式</p><div class="table-container"><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>r</td><td>以只读方式打开文件。文件的指针将会再文件的开头。这是默认模式</td></tr><tr><td>w</td><td>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，原有内容会被删除，如果该文件不存在，创建新文件。</td></tr><tr><td>a</td><td>打开一个文件用于追加。如果该文件已存在，新的内容将会被写入到已有的内容。如果该文件不存在，创建新文件进行写入。</td></tr></tbody></table></div><h4 id="操作总汇"><a href="#操作总汇" class="headerlink" title="操作总汇"></a>操作总汇</h4><div class="table-container"><table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>文件对象 = open(file,mode,encoding)</td><td>打开文件获取文件对象</td></tr><tr><td>文件对象.read(num)</td><td>读取指定长度字节，不指定num读取文件全部</td></tr><tr><td>文件对象.readline()</td><td>读取一行</td></tr><tr><td>文件对象.readlines()</td><td>读取全部行，得到列表</td></tr><tr><td>for line in 文件对象</td><td>for循环文件行，一次循环得到一行数据</td></tr><tr><td>文件对象.close()</td><td>关闭文件对象</td></tr><tr><td>with open() as f</td><td>通过with open语法打开文件，可以自动关闭</td></tr><tr><td>文件对象.wirte()</td><td>写入内容</td></tr><tr><td>文件对象.flush()</td><td>刷新内容到硬盘里</td></tr></tbody></table></div><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">可能发生异常的语句</span><br><span class="line">except 异常 as 别名:</span><br><span class="line">出现异常的手段</span><br><span class="line">else:</span><br><span class="line">未出现异常时应做的事情</span><br><span class="line">finally:</span><br><span class="line">不管出没出异常都会做的事情</span><br></pre></td></tr></table></figure><h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><h4 id="概述：-1"><a href="#概述：-1" class="headerlink" title="概述："></a>概述：</h4><p>就是一个Python文件，里面有类，函数，变量，我们可以拿来用（导入模块去使用）</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[from 模块名] import [模块|类|变量|函数|*] [as 别名]</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>from可以省略，直接import即可</li><li>as别名可以省略</li><li>通过“.”来确定层级关系</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_main_变量的功能是？</span><br><span class="line">if _main_==&quot;_main_&quot;表示，只有当前程序是直接执行的才会进入if内部，如果是被导入的，则if无法进入</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">不同模块，同名的功能，如果都被导入，那么后导入的会覆盖先导入的</span><br><span class="line">_all_变量可以控制import*的时候那些功能可以被导入</span><br><span class="line"></span><br><span class="line">什么是Python的包？</span><br><span class="line">包就是一个文件夹，里面可以存放许多Python的模块（代码文件），通过包，在逻辑上将一批模块归为一类，方便使用。</span><br><span class="line"></span><br><span class="line">_init_.py文件的作用？</span><br><span class="line">创建包会默认自动创建的文件，通过这个文件来表示一个文件夹是Python的包，而非普通的文件夹。</span><br><span class="line"></span><br><span class="line">_all_变量的作用？</span><br><span class="line">同模块中学习到的是一个作用，控制import*能够导入的内容</span><br></pre></td></tr></table></figure><h3 id="第三方包"><a href="#第三方包" class="headerlink" title="第三方包"></a>第三方包</h3><h4 id="概述：-2"><a href="#概述：-2" class="headerlink" title="概述："></a>概述：</h4><p>非Python官方制作的包，具有丰富的功能，可以提升我们题高开发效率，如：</p><ul><li>科学计算中常用的：numpy包</li><li>数据分析中常用的：pandas包</li><li>大数据计算中常用的：pyspark，apache-flink包</li><li>图形可视化常用的：matplotlib，pyecharts</li><li>人工智能常用的：tensorflow</li><li>等</li></ul><h4 id="安装第三方包-pip"><a href="#安装第三方包-pip" class="headerlink" title="安装第三方包-pip"></a>安装第三方包-pip</h4><p>利用Python内置的pip程序</p><ul><li>打开我们许久未见的：命令提示符程序，在里输入：</li><li>pip install 包名称</li><li>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> 包名称</li></ul><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><h4 id="什么是json"><a href="#什么是json" class="headerlink" title="什么是json"></a>什么是json</h4><ul><li>Json是一种轻量级的数据交互格式。可以按照json指定的格式去组织和封装数据</li><li>json本质上是一个带有特定格式的字符串</li></ul><p>主要功能：json就是一种在各个编程语言中流通的数据格式（各种编程语言的中转站），负责不同编程语言中的数据传递和交互，类似于：</p><ul><li>国际通用语言—英语</li><li>全中国通用语言—普通话</li></ul><p>Python语言使用JSON有很大优势，因为：JSON无非就是一个单独的字典或者一个内部元素都是字典的列表</p><p>所以JSON可以直接和Python的字典或列表无缝转换。</p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><div class="table-container"><table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>json.dumps(data)</td><td>将python数据转换为json数据，如果有中文数据可以使用：ensure_ascii=False参数来确保中文正常转换</td></tr><tr><td>json.loads(data)</td><td>将json数据转换为Python列表或者字典</td></tr></tbody></table></div><h4 id="PyEcharts模块"><a href="#PyEcharts模块" class="headerlink" title="PyEcharts模块"></a>PyEcharts模块</h4><p>开发可视化图使用的技术栈是：</p><p>Echarts框架的Python版本：PyEcharts包</p><p>如果查看官方示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打开官方画廊：https://gallery.pyecharts.org/#/README</span><br></pre></td></tr></table></figure><h4 id="基础折线图"><a href="#基础折线图" class="headerlink" title="基础折线图"></a>基础折线图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 导包Line功能构建折线图对象</span><br><span class="line">from pycharts.charts import Line</span><br><span class="line"></span><br><span class="line"># 得到折线图对象</span><br><span class="line">line = line()</span><br><span class="line"></span><br><span class="line"># 添加x轴数据</span><br><span class="line">line.add_xaxis([&#x27;中国&#x27;,&#x27;美国&#x27;,&#x27;英国&#x27;])</span><br><span class="line"></span><br><span class="line"># 添加y轴数据</span><br><span class="line">line.add_yaxis(&quot;GDP&quot;,[30,20.10])</span><br><span class="line"></span><br><span class="line"># 生成图表</span><br><span class="line">line,render()</span><br></pre></td></tr></table></figure><p>全局配置选项</p><ul><li>配置图标的标题</li><li>配置图列</li><li>配置鼠标移动效果</li><li>配置工具栏</li><li>等整体配置项 </li></ul><h4 id="基础地图"><a href="#基础地图" class="headerlink" title="基础地图"></a>基础地图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 导包map实现对象创造</span><br><span class="line">from pycharts.charts import Map</span><br><span class="line"></span><br><span class="line"># 准备地图对象</span><br><span class="line">map = Map()</span><br><span class="line"></span><br><span class="line"># 准备数据</span><br><span class="line">data = [</span><br><span class="line">(&quot;北京&quot;,99),</span><br><span class="line">(&quot;上海&quot;,199),</span><br><span class="line">(&quot;湖南&quot;,299),</span><br><span class="line">(&quot;台湾&quot;,399),</span><br><span class="line">(&quot;广东&quot;,499)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 添加数据</span><br><span class="line">map.add(&quot;测试地图&quot;,data,&quot;china&quot;)</span><br><span class="line"></span><br><span class="line">#绘图</span><br><span class="line">map.render()</span><br></pre></td></tr></table></figure><h4 id="基础柱状图"><a href="#基础柱状图" class="headerlink" title="基础柱状图"></a>基础柱状图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 导包Bar</span><br><span class="line">from pyecharts.charts import Bar</span><br><span class="line">from pyecharts.options import LabelOpts</span><br><span class="line"></span><br><span class="line"># 构造柱状图对象</span><br><span class="line">bar = Bar（）</span><br><span class="line"></span><br><span class="line"># 添加x轴数据</span><br><span class="line">bar.add_xaxis([&quot;中国&quot;,&quot;英国&quot;,&quot;美国&quot;])</span><br><span class="line"></span><br><span class="line"># 添加y轴数据</span><br><span class="line">bar.add_yaxis(&quot;GDP&quot;,[30,20.10],label_opts=LabelOpts(position=&quot;right&quot;))</span><br><span class="line"></span><br><span class="line"># 反转x和y轴</span><br><span class="line">bar.reversal_axis()</span><br><span class="line"></span><br><span class="line"># 绘图</span><br><span class="line">bar.render(&quot;基础柱状图.html&quot;)</span><br></pre></td></tr></table></figure><p>基础时间柱状图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 导包Bar</span><br><span class="line">from pyecharts.charts import Bar，Timeline</span><br><span class="line">from pyecharts.options import LabelOpts </span><br><span class="line"></span><br><span class="line"># 构造时间线对象</span><br><span class="line">timeline = Timeline()</span><br><span class="line"></span><br><span class="line"># 在时间线内添加柱状图对象</span><br><span class="line">timeline.add(bar1,&quot;点1&quot;)</span><br><span class="line">timeline.add(bar2,&quot;点2&quot;)</span><br><span class="line">timeline.add(bar3,&quot;点3&quot;)</span><br><span class="line"></span><br><span class="line"># 设置自动播放</span><br><span class="line">timeline.add_schema(</span><br><span class="line">play_interval=1000,           #自动播放的时间间隔，单位毫秒</span><br><span class="line">is_timeline_show=True,        #是否在自动播放的时间，显示时间线</span><br><span class="line">is_auto_play=True,            #是否自动播放</span><br><span class="line">is_loop_play=True             #是否循环自动播放</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 绘图</span><br><span class="line">timeline.render(&quot;基础时间柱状图.html&quot;)</span><br></pre></td></tr></table></figure><p>设置主题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from pyecharts.globals import ThemeType</span><br><span class="line">timeline = Timeline(</span><br><span class="line">&#123;&quot;theme&quot;:themeType.LIGHT&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h4><p>就是使用字符串来定义规则，并通过规则去验证字符串是否匹配</p><h4 id="正则的三个基础方法："><a href="#正则的三个基础方法：" class="headerlink" title="正则的三个基础方法："></a>正则的三个基础方法：</h4><p>Python正则表达式，使用re模块，并基于re模块中的三个基础方法来做正则匹配。分别是：match,search,findall三个基础方法</p><ul><li><p>re.match(匹配规则，被匹配字符串)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">从被匹配字符串开头进行匹配，匹配成功返回匹配对象（包含匹配的信息），匹配不成功返回空</span><br><span class="line">s = &#x27;python itheima python itheima python itheima&#x27;</span><br><span class="line"></span><br><span class="line">result = re.match(&#x27;python&#x27;,s)</span><br><span class="line">print(result) #&lt;re.Match object; span=(0,6),match=&#x27;python&#x27;</span><br><span class="line">print(resuit.span()) #(0,6)</span><br><span class="line">print(resuit.group()) #python</span><br><span class="line"></span><br><span class="line">s = &#x27;1python itheima python python itheima&#x27;</span><br><span class="line"></span><br><span class="line">result = re.match(&#x27;python&#x27;,s)</span><br><span class="line">print(result) #None</span><br></pre></td></tr></table></figure></li><li><p>search（匹配规则，被匹配字符串）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">搜索整个字符串，找出匹配的。从前向后，找到第一个后，就停止，不会继续向后</span><br><span class="line">s = &#x27;1phthon666itheima666python666&#x27;</span><br><span class="line"></span><br><span class="line">result = re.search(&#x27;python&#x27;,s)</span><br><span class="line">print(result)           #&lt;re.Match object;span=(1,7),match=&#x27;python&#x27;&gt;</span><br><span class="line">print(result.span())    #(1,7)</span><br><span class="line">print(result.group())   #python</span><br><span class="line"></span><br><span class="line">整个字符串都找不到，返回None</span><br><span class="line">s = &#x27;itheima666&#x27;</span><br><span class="line"></span><br><span class="line">result = re.search(&#x27;python&#x27;,s)</span><br><span class="line">print(result)           #Nome</span><br></pre></td></tr></table></figure></li><li><p>findall(匹配规则，被匹配字符串)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">匹配整个字符串，找出全部匹配项</span><br><span class="line">s = &#x27;1python666itheima666python666&#x27;</span><br><span class="line"></span><br><span class="line">result = re.findall(&#x27;python&#x27;,s)</span><br><span class="line">print(result)            #&#123;&#x27;python&#x27;,&#x27;python&#x27;&#125;</span><br><span class="line"></span><br><span class="line">找不到返回空list:[]</span><br><span class="line">s = &#x27;1python666itheima666python666&#x27;</span><br><span class="line"></span><br><span class="line">result = re.findall(&#x27;itcast&#x27;,s)</span><br><span class="line">print(resuit)            #[]</span><br></pre></td></tr></table></figure></li></ul><h4 id="元字符匹配"><a href="#元字符匹配" class="headerlink" title="元字符匹配"></a>元字符匹配</h4><p>单字符匹配：</p><div class="table-container"><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>.</td><td>匹配任意一个字符（除了\n），\ .匹配点本身</td></tr><tr><td>[]</td><td>匹配[]中列举的字符</td></tr><tr><td>\d</td><td>匹配数字，即0-9</td></tr><tr><td>\D</td><td>匹配非数字</td></tr><tr><td>\s</td><td>匹配空白，及空格，tab键</td></tr><tr><td>\S</td><td>匹配非空白</td></tr><tr><td>\w</td><td>匹配单词字符，即a-z，A-Z，0-9，_</td></tr><tr><td>\W</td><td>匹配非单词字符</td></tr></tbody></table></div><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字符串 s = &quot;itheima1@@python2!!666##itcast3&quot;</span><br><span class="line">找出全部数字：re.findall(r&#x27;\d&#x27;,s)</span><br><span class="line">找出特殊字符：re.findall(r&#x27;\W&#x27;,s)</span><br><span class="line">找出全部英文字母：re.findall(r&#x27;[a-zA-Z]&#x27;,s)</span><br><span class="line">[]内可以写：[a-zA-Z0-9]这三种范围组合或指定单个字符如[aceDFG135]</span><br><span class="line">注意：字符串的r标记表示，字符串内转移字符无效，作为普通字符使用</span><br></pre></td></tr></table></figure><p>数量匹配：</p><div class="table-container"><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>*</td><td>匹配前一个规则的字符现0至无数次</td></tr><tr><td>+</td><td>匹配前一个规则的字符出现1至无数次</td></tr><tr><td>？</td><td>匹配前一个规则的字符出现0次或1次</td></tr><tr><td>{m}</td><td>匹配前一个规则的字符出现m次</td></tr><tr><td>{m,}</td><td>匹配前一个规则的字符出现最少m次、</td></tr><tr><td>{m,n}</td><td>匹配前一个规则的字符出现m到n次</td></tr></tbody></table></div><p>边界匹配：</p><div class="table-container"><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>^</td><td>匹配字符串开头</td></tr><tr><td>$</td><td>匹配字符串结尾</td></tr><tr><td>\b</td><td>匹配一个单词的边界</td></tr><tr><td>\B</td><td>匹配非单词边界</td></tr></tbody></table></div><p>分组匹配：</p><div class="table-container"><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>\</td><td></td><td>比配左右任意一个表达式</td></tr><tr><td>()</td><td>将括号中字符作为一个分组</td></tr></tbody></table></div><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><h4 id="服务端开发"><a href="#服务端开发" class="headerlink" title="服务端开发"></a>服务端开发</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#socktr创建对象</span><br><span class="line">import socket</span><br><span class="line">socket_server = socker.socket()</span><br><span class="line"></span><br><span class="line">#绑定socket_server到指定IP和地址</span><br><span class="line">socker_server.bind(host.port)</span><br><span class="line"></span><br><span class="line">#服务器开始监听端口</span><br><span class="line">socker_server.listen(backlog)</span><br><span class="line">#backlog为int整数，表示允许的连接数量，超过的会等待，可以不填满，不填会自动设置一个合理值</span><br><span class="line"></span><br><span class="line">#接听客服端连接，获取连接对象</span><br><span class="line">conn.address = socker_server.accept()</span><br><span class="line">print(f&quot;接受到客户端连接，连接来自：&#123;address&#125;&quot;)</span><br><span class="line">#accept方法是阻塞方法，如果没有连接，会卡再当前这一行不向下执行代码</span><br><span class="line">#accpet返回的是一个二元元组，可以使用上述形式，用两个变量接受二元元组的2个元素</span><br><span class="line"></span><br><span class="line">#客户端连接后，通过recv方法，接收客户端发送的消息</span><br><span class="line">while True:</span><br><span class="line">data = conn.recv(1024).decode(&quot;UTF-8&quot;)</span><br><span class="line">#recv方法的返回值是字节数组（Bytes），可以通过decode使用UTF-8解码为字符串</span><br><span class="line">#recv方法的传参是buffsize，缓冲区大小，一般设置为1024即可</span><br><span class="line">if data == &#x27;exit&#x27;:</span><br><span class="line">break</span><br><span class="line">print(&quot;接收到发送来的数据：&quot;，data)</span><br><span class="line"># 可以通过while True无限循环来持续和客户端进行数据交互</span><br><span class="line">#可以通过判定客户端发来的特殊标记，如exit，来退出无限循环</span><br><span class="line"></span><br><span class="line">#通过conn（客户端当次连接对象），调用send方法可以回复消息</span><br><span class="line">while True:</span><br><span class="line">data = conn.recv(1024).decode(&quot;UTF-8&quot;)</span><br><span class="line">if data == &#x27;exit&#x27;:</span><br><span class="line">break </span><br><span class="line">print(&quot;接收到发送来的数据：&quot;，data)</span><br><span class="line">conn.send(&quot;你好呀哈哈哈&quot;，encode(&quot;UTF-8&quot;))</span><br><span class="line"></span><br><span class="line">#conn（客户端当次连接对象)和socket_server对象调用close方法，关闭连接</span><br></pre></td></tr></table></figure><p>下载网络调试助手作为客户端<br><a href="https://github.com/nicedayzhu/netAssist/releases">https://github.com/nicedayzhu/netAssist/releases</a></p><h4 id="客服端开发"><a href="#客服端开发" class="headerlink" title="客服端开发"></a>客服端开发</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#创建socket对象</span><br><span class="line">import socket</span><br><span class="line">socket_client = socket.socket()</span><br><span class="line"></span><br><span class="line">#连接到服务端</span><br><span class="line">socket_client.connect((&quot;localhost&quot;,8888))</span><br><span class="line"></span><br><span class="line">#发送消息</span><br><span class="line">while True:  #可以通过无限循环来确保持续的发送消息给服务端</span><br><span class="line">send_msg = input(&quot;请输入要发送的消息&quot;)</span><br><span class="line">if send_msg = &#x27;exit&#x27;:</span><br><span class="line"># 通过特殊标记来确保可以退出无限循环</span><br><span class="line">break</span><br><span class="line">socket_client.send(send_msg.encode(&quot;UTF-8&quot;)</span><br><span class="line"># 消息需要编码为字节数组（UTF-8编码)</span><br><span class="line"></span><br><span class="line">#接收返回消息</span><br><span class="line">while True:</span><br><span class="line">send_msg =input(&quot;请输入要发送的消息&quot;).encode（&quot;UTF-8&quot;)</span><br><span class="line">socket_client.send(send_msg)</span><br><span class="line"></span><br><span class="line">recv_data = socket_client.recv(1024) # 1024是缓冲区大小，一般1024即可</span><br><span class="line">#recv方法是阻塞式的，即不接收到返回，就卡在这里等待</span><br><span class="line"></span><br><span class="line">print(&quot;服务端回复消息为：&quot;,recv_data.decode(&quot;UTF-8&quot;）) </span><br><span class="line">#接受的消息需要通过UTF-8解码为字符串</span><br><span class="line"></span><br><span class="line">#关闭链接</span><br><span class="line">socket_client.close()  # 最后通过close关闭链接</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑马程序员java自学笔记（包括Java环境配置与IDEA的下载地址）</title>
      <link href="/posts/4454963.html"/>
      <url>/posts/4454963.html</url>
      
        <content type="html"><![CDATA[<h3 id="java学习的开始"><a href="#java学习的开始" class="headerlink" title="java学习的开始"></a>java学习的开始</h3><h4 id="环境的搭建"><a href="#环境的搭建" class="headerlink" title="环境的搭建"></a>环境的搭建</h4><p>请参考如下文章：</p><p><a href="https://blog.csdn.net/u011397981/article/details/129495097">【Java】java 环境配置(详细教程)_java配置环境教程-CSDN博客</a></p><h4 id="常用的DOS命令："><a href="#常用的DOS命令：" class="headerlink" title="常用的DOS命令："></a>常用的DOS命令：</h4><ul><li>按下win+R</li><li>输入cmd</li></ul><div class="table-container"><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>盘符名称：</td><td>盘符切换。E:回车，表示切换到E盘</td></tr><tr><td>dir</td><td>查看当前路径下的内容</td></tr><tr><td>cd 目录</td><td>进入单级目录</td></tr><tr><td>cd..</td><td>退回到上级目录</td></tr><tr><td>cd 目录1\目录2 \ …</td><td>进入多级目录</td></tr><tr><td>cd\</td><td>退回到盘符目录</td></tr><tr><td>cls</td><td>清屏</td></tr><tr><td>exit</td><td>退出命令提示符窗口</td></tr></tbody></table></div><h4 id="HelloWorld案例"><a href="#HelloWorld案例" class="headerlink" title="HelloWorld案例"></a>HelloWorld案例</h4><ul><li><p>新建一个文本文档文件，修改名称为HelloWorld.java</p></li><li><p>用记事本打开HelloWorld.java文件，输入程序内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">System.out.println(&quot;HelloWorld&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;//保存文件Crtl + s</span><br></pre></td></tr></table></figure></li><li><p>打开命令提示符窗口，进入HelloWorld.java所在的目录。输入指令编译和执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编译：javac 文件名.java</span><br><span class="line">范例：javac HelloWorld.java</span><br><span class="line"></span><br><span class="line">执行：java 类名</span><br><span class="line">范例: java Hello World</span><br></pre></td></tr></table></figure></li></ul><h4 id="编译工具的下载："><a href="#编译工具的下载：" class="headerlink" title="编译工具的下载："></a>编译工具的下载：</h4><p><a href="https://www.jetbrains.com/idea/download/other.html">Other Versions - IntelliJ IDEA (jetbrains.com)</a> </p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>概述：</p><p>方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集</p><p>注意：</p><ul><li>方法必须先创建才能使用，该过程成为方法的定义</li><li>方法创建后并不是直接使用，需要手动使用后才会执行，该过程成为方法的调用</li></ul><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>构造方法是一个特殊的方法（方法名为类名的方法）</p><p>作用：创建对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">public class 类名&#123;</span><br><span class="line">修饰符 类名（参数）&#123;</span><br><span class="line">//注意：如果使用带参的构造方法，必须先创一个无参的构造方法</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能：主要是完成对象数据的初始化</p><h4 id="构造方法的注意事项"><a href="#构造方法的注意事项" class="headerlink" title="构造方法的注意事项"></a>构造方法的注意事项</h4><p>构造方法的创建</p><ul><li>如果没有定义构造方法，系统将会给一个默认的无参构造方法</li><li>如果定义了构造方法，系统将不会提供默认的构造方法</li></ul><p>构造方法的重载</p><ul><li>如果定义了带参构造方法，还要使用无参构造方法，就必须再写一个无参构造方法</li></ul><p>推荐的使用方式</p><ul><li>无论是否使用，都手工书写无参构造方法</li></ul><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="什么是对象："><a href="#什么是对象：" class="headerlink" title="什么是对象："></a>什么是对象：</h4><p>万物皆为对象，客观存在的事物都是对象</p><h4 id="什么是类："><a href="#什么是类：" class="headerlink" title="什么是类："></a>什么是类：</h4><p>类是对现实生活中一类具有共同属性和行为的事物的抽象</p><h4 id="类的特点："><a href="#类的特点：" class="headerlink" title="类的特点："></a>类的特点：</h4><ul><li>类是对象的数据类型</li><li>类是具有相同属性和行为的一组对象的集合</li></ul><h4 id="什么是对象的属性"><a href="#什么是对象的属性" class="headerlink" title="什么是对象的属性"></a>什么是对象的属性</h4><p>属性：</p><p>对象具有的各种特征，每个对象的每个属性都拥有特定的值</p><h4 id="什么是对象的行为"><a href="#什么是对象的行为" class="headerlink" title="什么是对象的行为"></a>什么是对象的行为</h4><p>行为：</p><p>对象能够执行的操作</p><h4 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h4><p>类是对象的抽象，对象是类的实体</p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;数据类型&gt; 对象 = new ArrayList&lt;&gt;()</span><br></pre></td></tr></table></figure><h4 id="添加方法-E-e是元素的意思"><a href="#添加方法-E-e是元素的意思" class="headerlink" title="添加方法(E e是元素的意思)"></a>添加方法(E e是元素的意思)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e);</span><br><span class="line">将指定的元素追加到此集合的末尾</span><br><span class="line">public void add(int index,E element);</span><br><span class="line">在此集合中指定位置插入指定元素</span><br><span class="line">public booleam remove(Object o);</span><br><span class="line">删除指定元素，返回删除是否成功</span><br><span class="line">public E remove(int index);</span><br><span class="line">删除指定索引处的元素，返回被删除的元素</span><br><span class="line">public E set(int index,E element);</span><br><span class="line">修改指定位置的元素，返回被修改的元素</span><br><span class="line">public E get(int index);</span><br><span class="line">返回指定索引处元素</span><br><span class="line">public int size();</span><br><span class="line">返回集合元素的个数</span><br></pre></td></tr></table></figure><h3 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h3><h4 id="特有功能（方法）"><a href="#特有功能（方法）" class="headerlink" title="特有功能（方法）"></a>特有功能（方法）</h4><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public void addFirst(E e)</td><td>在该列表开头插入指定的元素</td></tr><tr><td>public void addLast(E e)</td><td>将指定的元素追加到此列表的末尾</td></tr><tr><td>public E getFirst()</td><td>返回此列表中的第一个元素</td></tr><tr><td>public E getLast()</td><td>返回此列表中最后一个元素</td></tr><tr><td>public E removeFirst()</td><td>从此列表中删除并返回第一个元素</td></tr><tr><td>public E removeLast()</td><td>从此列表中删除并返回最后一个元素</td></tr></tbody></table></div><h3 id="LinkedHashSet集合"><a href="#LinkedHashSet集合" class="headerlink" title="LinkedHashSet集合"></a>LinkedHashSet集合</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>哈希表和链表实现的Set接口，具有可预测的迭代次序</li><li>由链表保证元素有序，也就是说元素的存储和取出顺序是一致的</li><li>由哈希表保证元素唯一，也就是说没有重复的元素</li></ul><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li>不包含重复元素的集合</li><li>没有带索引的方法，所以不能使用普通for循环遍历</li></ul><h4 id="HashSet-集合"><a href="#HashSet-集合" class="headerlink" title="HashSet()集合"></a>HashSet()集合</h4><p>HashSet集合特点</p><ul><li>底层数据结构是哈希表</li><li>对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致</li><li>没有索引的方法，所以不能使用普通for循环遍历</li><li>由于是Set集合，所以是不包含重复元素的集合</li></ul><p>HashSet集合保证元素唯一性源码分析（太多了，也不是特别重要，自己了解）</p><h4 id="TreeSet集合"><a href="#TreeSet集合" class="headerlink" title="TreeSet集合"></a>TreeSet集合</h4><p>特点：</p><ul><li>元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方式取决于构造方法<ul><li>TreeSet():根据去元素的自然排序进行排序</li><li>TreeSet(Comparator comparator):根据指定的比较器进行排序</li></ul></li><li>没有带索引的方法，所以不能使用普通for循环遍历</li><li>由于是Set集合，所以不包含重复元素的集合</li></ul><h4 id="自然排序Comparable的使用"><a href="#自然排序Comparable的使用" class="headerlink" title="自然排序Comparable的使用"></a>自然排序Comparable的使用</h4><ul><li>用TreeSer集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的</li><li>自然排序，就是让元素所属的类实现Comparable接口，重写comparaTo(T o)方法</li><li>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</li></ul><h4 id="比较器排序Comparator的使用"><a href="#比较器排序Comparator的使用" class="headerlink" title="比较器排序Comparator的使用"></a>比较器排序Comparator的使用</h4><ul><li>用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的</li><li>比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compara(T o1,T o2)方法</li><li>重写方法时，一定要注意排序规则必须按照要求的主要要求和次要条件来来写</li></ul><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="Collection集合概述："><a href="#Collection集合概述：" class="headerlink" title="Collection集合概述："></a>Collection集合概述：</h4><ul><li>是单例集合的顶层接口，他表示一组对象，这些对象也称为Collection的元素</li><li>JDK不提供此接口的任何直接实现，他提供更具体的子接口（如Set和List）实现</li></ul><h4 id="创建Collection集合的对象"><a href="#创建Collection集合的对象" class="headerlink" title="创建Collection集合的对象"></a>创建Collection集合的对象</h4><ul><li>多态的方式</li><li>具体的实现类ArrayList</li></ul><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>boolean add(E e)</td><td>添加元素</td></tr><tr><td>boolean remove(Object o)</td><td>从集合中移除指定的元素</td></tr><tr><td>void clear()</td><td>清空集合中的元素</td></tr><tr><td>boolean contains(Object o)</td><td>判断集合中是否存在指定的元素</td></tr><tr><td>boolean isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>in size()</td><td>集合的长度，也就是集合中的元素的个数</td></tr></tbody></table></div><h4 id="Collection集合的遍历"><a href="#Collection集合的遍历" class="headerlink" title="Collection集合的遍历"></a>Collection集合的遍历</h4><p>Iterator</p><ul><li>Iterator<E>iterator():返回此集合中元素的迭代器，通过集合的iterator()方法得到</li><li>迭代器是通过集合的iterator()方法得到的，所以我们说它是依赖于集合而存在的</li></ul><p>Iterator中的常用方法</p><ul><li>E next()：返回迭代中的下一个元素</li><li>boolean hasNext()：如果迭代具有更多元素，则返回true</li></ul><h3 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>是针对集合操作的工具类</p><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;?super T&gt;&gt; void sort(List&lt;T&gt; list)</span><br><span class="line">将指定的列表按升序排序</span><br><span class="line">public static void reverse(List&lt;?&gt;list)</span><br><span class="line">反转指定列表中元素的顺序</span><br><span class="line">public static void shuffle(List&lt;?&gt;list)</span><br><span class="line">使用默认的随机源随机排列指定的列表</span><br></pre></td></tr></table></figure><h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><p>概述：</p><ul><li>有序集合（也称为序列），用户可以精确控制列表中的每个元素的插入位置。用户可以通过整数索引访问元素，并搜索元素</li><li>与Set集合不同，列表通常允许重复的元素</li></ul><p>List集合特点</p><ul><li>有序：存储和取出的元素顺序一致</li><li>可重复：存储的元素可以重复</li></ul><h4 id="List集合特有方法"><a href="#List集合特有方法" class="headerlink" title="List集合特有方法"></a>List集合特有方法</h4><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void add(int index,E element)</td><td>在此集合中的指定位置插入指定的元素</td></tr><tr><td>E remove(int index)</td><td>删除指定索引处的元素，返回被删除的元素</td></tr><tr><td>E set(int index,E element)</td><td>修改指定索引处的元素，返回被修改的元素</td></tr><tr><td>E get(int index)</td><td>返回指定索引处的元素</td></tr></tbody></table></div><h4 id="并发修改异常-ConcurrentModificationException"><a href="#并发修改异常-ConcurrentModificationException" class="headerlink" title="并发修改异常(ConcurrentModificationException)"></a>并发修改异常(ConcurrentModificationException)</h4><p>产生原因：</p><p>迭代器遍历的过程中，通过集合对象修改了集合中元素的长度，造成了迭代器获取元素中判断预期修改值和实际修改值不一致</p><p>解决方案：</p><p>用for循环遍历，然后用集合对象做对应的操作即可</p><h4 id="ListIterator-列表迭代器"><a href="#ListIterator-列表迭代器" class="headerlink" title="ListIterator(列表迭代器)"></a>ListIterator(列表迭代器)</h4><p>作用：</p><ul><li>通过List集合的listIterator()方法得到，所以说它是List集合特有的迭代器</li><li>用于允许程序员沿任意方向遍历列表的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置</li></ul><p>ListIterator中常用方法：</p><ul><li>E next();返回迭代中的下一个元素</li><li>boolean hasNext();如果迭代具有更多元素，则返回true</li><li>E previous();返回列表中上一个元素</li><li>boolean hasPrevious();如果此列表迭代器在相反方向遍历列表时具有更对元素，则返回true</li><li>void add(E e);指定的元素插入列表  </li></ul><h4 id="List集合子类特点"><a href="#List集合子类特点" class="headerlink" title="List集合子类特点"></a>List集合子类特点</h4><p>常用子类：ArrayList，LinkedList</p><ul><li>Array List：底层数据结构是数组，查询快，增删慢</li><li>LinkedList：底层数据结构是链表，查询慢，增删快</li></ul><h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><p>概述：</p><ul><li>Interface Map<k,V> K:键的类型 V:值的类型</li><li>将键映射到值的对象：不能包含重复的键：每个键可以映射到最多一个值</li><li>举例： 学生的学号（键）和姓名（值）</li></ul><h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>V put (K key,V value)</td><td>添加元素</td></tr><tr><td>V remove(Object key)</td><td>根据键删除键值对元素</td></tr><tr><td>void clear()</td><td>移除所有的键值对元素</td></tr><tr><td>boolean containsKey(Object key)</td><td>判断集合是否包含指定的键</td></tr><tr><td>boolean containsValue(Object value)</td><td>判断集合是否包含指定的值</td></tr><tr><td>boolean isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>int size()</td><td>集合的长度，也就是集合中键值对的个数</td></tr></tbody></table></div><h4 id="获取功能"><a href="#获取功能" class="headerlink" title="获取功能"></a>获取功能</h4><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>V get(Object key)</td><td>根据键获取值</td></tr><tr><td>Set<K> keySet()</td><td>获取所有键的集合</td></tr><tr><td>Collection<V>values()</td><td>获取所有值的集合</td></tr><tr><td>Set<Map.Entry<K,V>&gt;entrySet()</td><td>获取所有键值对对象的集合</td></tr></tbody></table></div><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><ul><li>简化了数组和Collection集合的遍历</li><li>实现了Iterable接口的类允许其对象成为增强型for语句的目标</li><li>它是JDK5之后出现的，其内部原理是一个Iterator迭代器</li></ul><h4 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h4><p>for(元素数据类型 变量名：数组或者Collection集合){</p><p>//在此处使用变量即可，该变量就是元素</p><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">范例：</span><br><span class="line">int[] arr = &#123;1,2,3,4,5&#125;;</span><br><span class="line">for(int i:arr)&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="概述：-1"><a href="#概述：-1" class="headerlink" title="概述："></a>概述：</h4><p>数据结构是计算机存储、组织数据的方式。是指相互之间存在一种或多种特定关系的数据元素的集合（通常情况下，精心选择的数据结构可以带来更高的运行或着存储效率）</p><h4 id="常见数据结构之栈"><a href="#常见数据结构之栈" class="headerlink" title="常见数据结构之栈"></a>常见数据结构之栈</h4><p>栈是一种数据先进后出的数据模型，有栈顶元素和栈低元素</p><p>数据进入栈模型的过程称为：压/进栈</p><p>数据离开栈模型的过程称为：弹/出栈</p><h4 id="常见数据结构之队列"><a href="#常见数据结构之队列" class="headerlink" title="常见数据结构之队列"></a>常见数据结构之队列</h4><p>队列是一种数据先进先出的模型，入队列方向为后端，出队列方向为前端</p><p>数据从后端进入队列模式的过程称为：入队列</p><p>数据从前端离开队列模型的过程称为：出队列</p><h4 id="常见数据结构之数组"><a href="#常见数据结构之数组" class="headerlink" title="常见数据结构之数组"></a>常见数据结构之数组</h4><p>概述：数组是一种查询快，增删慢的模型</p><ul><li>查询数据通过索引定位，查询任意数据耗时相同，<strong>查询效率高</strong></li><li>删除数据时，要将原始数据删除，同时后面每个数据前移，<strong>删除数据效率低</strong></li><li>添加数据是，添加位置后的每个数据后移，在添加元素，<strong>添加效率极低</strong></li></ul><h4 id="常见数据结构之链表"><a href="#常见数据结构之链表" class="headerlink" title="常见数据结构之链表"></a>常见数据结构之链表</h4><p>概述：有头结点，有结点，结点由数据（是存储具体的数据，也是这个结点的存储位置）和地址（下个结点的地址）构成，头结点由head和^(指空地址，节点指向空地址表示结束)</p><p>特点：</p><p>链表是一种增删快的模型（对比数组）</p><p>链表是一种查询慢的模型（对比数组）</p><h4 id="常见数据结构之哈希表"><a href="#常见数据结构之哈希表" class="headerlink" title="常见数据结构之哈希表"></a>常见数据结构之哈希表</h4><p>概述：JDK8之前，底层采用数据+链表实现，可以说是一个元素为链表的数组，JDK8以后，在长度比较长的时候，底层实现了优化</p><p>如何存储数据：</p><p>哈希表默认由16个单位容量（0-15），然后将存储的数据的哈希值对16取余，对应的余数放进列表，然后在列表里依次判断是否重复，如果没有，则添加</p><h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p>概述：System包含几个有用得类字段和方法，它不能被实例化</p><p>常用方法：</p><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static void exit(int status)</td><td>终止当前运行得Java虚拟机，非零表示异常终止</td></tr><tr><td>public static long currentTimeMillis()</td><td>返回当前时间（以毫秒为单位）</td></tr></tbody></table></div><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="概述：-2"><a href="#概述：-2" class="headerlink" title="概述："></a>概述：</h4><ul><li>是面向对象三大特征之一（封装，继承，多态）</li><li>是面向对象编程语言对客观世界的模拟，客观世界里成员变量都在影藏在对象内部的，外界无法直接操作</li></ul><h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><ul><li>将类的信息隐藏在内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问</li><li>成员变量private，提供了对应的getXxx()/setXxx()方法</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>通过方法来控制成员变量的操作，提高了代码的安全性</li><li>把代码用的方法进行封装，提高了代码的复用性</li></ul><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><h4 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class 子类名 extends 父类&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="继承中子类的特点"><a href="#继承中子类的特点" class="headerlink" title="继承中子类的特点"></a>继承中子类的特点</h4><ul><li>子类可以有父类的内容</li><li>子类还可以有自己特有的内容</li></ul><h4 id="继承中变量的访问特点（在子类方法中访问一个变量）"><a href="#继承中变量的访问特点（在子类方法中访问一个变量）" class="headerlink" title="继承中变量的访问特点（在子类方法中访问一个变量）"></a>继承中变量的访问特点（在子类方法中访问一个变量）</h4><ul><li>子类局部范围找</li><li>子类成员范围找</li><li>父类成员范围找</li><li>如果没有就报错（不考虑父亲的父亲…）</li></ul><h4 id="继承中构造方法的访问特点"><a href="#继承中构造方法的访问特点" class="headerlink" title="继承中构造方法的访问特点"></a>继承中构造方法的访问特点</h4><p>子类中所有的构造方法默认都会访问父类中的无参的构造方法，这是为什么？</p><ul><li>因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成数据的初始化</li><li>每一个子类构造方法的第一条语句默认都是：super()</li></ul><p>如果父类中没有无参构造方法，只有带参构造方法，该这么办呢？</p><ul><li>通过使用super关键字去显示调用父类的带参构造方法</li><li>在父类中自己提供一个无参构造方法（推荐自己给出无参构造方法）</li></ul><h4 id="继承中成员方法的访问特点"><a href="#继承中成员方法的访问特点" class="headerlink" title="继承中成员方法的访问特点"></a>继承中成员方法的访问特点</h4><p>通过子类对象访问一个方法</p><ul><li>子类成员范围找</li><li>父类成员范围找</li><li>如果没有就报错（不考虑父亲的父亲…）</li></ul><p>java中继承的注意事项</p><ul><li>Java中类只支持单继承，不支持多继承</li><li>Java中类支持多层继承</li></ul><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>访问本类成员变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.成员变量</span><br></pre></td></tr></table></figure><p>访问本类构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this(...)</span><br></pre></td></tr></table></figure><p>访问本类成员方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.成员方法(...)</span><br></pre></td></tr></table></figure><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>访问父类成员变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super.成员变量</span><br></pre></td></tr></table></figure><p>访问父类构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super(...)</span><br></pre></td></tr></table></figure><p>访问父类成员方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super.成员方法(...)</span><br></pre></td></tr></table></figure><h3 id="Override-重写"><a href="#Override-重写" class="headerlink" title="@Override(重写)"></a>@Override(重写)</h3><ul><li>是一个注解</li><li>可以帮助我们检查重写方法声明的正确性</li></ul><p>方法重写注意事项</p><ul><li>私有方法不能被重写（父类私有成员子类是不能被继承的）</li><li>子类方法访问权限不能更低（public&gt;默认&gt;私有）</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态中成员访问特点</p><ul><li>成员变量：编译看左边，执行看左边</li><li>成员方法：编译看左边，执行看右边</li></ul><p>为什么成员变量和成员方法的访问不一样？</p><ul><li>因为成员方法有重写，而成员变量没有</li></ul><p>多态的好处与弊端</p><ul><li>多态的好处：提高了编程的扩展性（具体表现：定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作）</li><li>多态的弊端：不能使用子类的特有功能</li></ul><p>多态中的转型</p><ul><li><p>向上转型：从子到父，父类引用指向子类对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fu a = new zi()</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>向下转型：从父到子，父类引用转为子类对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zi b = (zi)a</span><br></pre></td></tr></table></figure></li></ul><h3 id="抽象类-abstract"><a href="#抽象类-abstract" class="headerlink" title="抽象类(abstract)"></a>抽象类(abstract)</h3><p>抽象类的特点</p><ul><li><p>抽象类和方法必须使用abstract关键字修饰</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract class 类名&#123;&#125;</span><br><span class="line">public abstract void eat()</span><br></pre></td></tr></table></figure></li><li><p>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</p></li><li><p>抽象类不能实例化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">抽象类如何实例化呢？参照多态的方法，通过子类对象实例化，这叫抽象类多态</span><br></pre></td></tr></table></figure></li><li><p>抽象类的子类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">要么重写抽象类中的所有抽象方法</span><br><span class="line">要么是抽象类</span><br></pre></td></tr></table></figure></li></ul><p>抽象类的成员特点</p><ul><li>成员变量可以是变量，也可以是常量</li><li>可以有构造方法，但是不能实例化，构造方法的作用是用于子类访问父类数据的初始化</li><li>成员方法中的抽象方法可以限定子类必须完成某些动作，而那些非抽象方法是为了提高代码的复用性</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用，而Java中的接口更多体现在对行为的抽象</p><h4 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h4><ul><li><p>接口关键字interface修饰</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface 接口名 &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>类实现接口用implements表示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class 类名 implements 接口名 &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口不能实例化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态</span><br><span class="line">多态的形式：具体类多态，抽象类多态，接口多态</span><br><span class="line">多态的前提：有继承或者实现关系；有方法重写；有父（类/接口）引用指向（子/实现）类对象</span><br></pre></td></tr></table></figure></li><li><p>接口的实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">要么重写接口中的所有抽象方法</span><br><span class="line">要么是抽象类</span><br></pre></td></tr></table></figure></li></ul><h4 id="接口的成员特点"><a href="#接口的成员特点" class="headerlink" title="接口的成员特点"></a>接口的成员特点</h4><ul><li><p>成员变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">只能是常量</span><br><span class="line">默认修饰符：public static final</span><br></pre></td></tr></table></figure></li><li><p>构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接口没有构造方法，因为接口主要是对行为进行抽象的，是没有具体存在</span><br><span class="line">一个类如果没有父类，就默认继承Object类</span><br></pre></td></tr></table></figure></li><li><p>成员方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">只能是抽象方法</span><br><span class="line">默认修饰符：public abstract</span><br></pre></td></tr></table></figure></li></ul><h4 id="类和接口的关系"><a href="#类和接口的关系" class="headerlink" title="类和接口的关系"></a>类和接口的关系</h4><ul><li>类和类的关系<ul><li>继承关系，只能单继承，但是可以多层继承</li></ul></li><li>类和接口的关系<ul><li>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</li></ul></li><li>接口和接口的关系<ul><li>继承关系，可以单继承，也可以多继承</li></ul></li></ul><h4 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h4><ul><li>成员区别<ul><li>抽象类：变量，常量，有构造方法，有抽象方法，也有非抽象方法</li><li>接口：常量，抽象方法</li></ul></li><li>关系区别<ul><li>类与类：继承，单继承</li><li>类与接口：实现，可以单实现，也可以多实现</li><li>接口与接口：继承，单继承，多继承</li></ul></li><li>设计理念区别<ul><li>抽象类：对类抽象，包括属性、行为</li><li>接口：对行为抽象，主要是行为</li></ul></li></ul><h3 id="形参和返回值"><a href="#形参和返回值" class="headerlink" title="形参和返回值"></a>形参和返回值</h3><h4 id="类名作为形参和返回值"><a href="#类名作为形参和返回值" class="headerlink" title="类名作为形参和返回值"></a>类名作为形参和返回值</h4><ul><li>方法的形参是类名，其实需要的是该类的对象</li><li>方法的返回值是类名，其实返回的是该类的对象</li></ul><h4 id="抽象类名作为形参和返回值"><a href="#抽象类名作为形参和返回值" class="headerlink" title="抽象类名作为形参和返回值"></a>抽象类名作为形参和返回值</h4><ul><li>方法的形参是抽象类名，其实需要的是该抽象类的子类对象</li><li>方法的返回值是抽象类名，其实返回的是抽象类的子类对象</li></ul><h4 id="接口名作为形参和返回值"><a href="#接口名作为形参和返回值" class="headerlink" title="接口名作为形参和返回值"></a>接口名作为形参和返回值</h4><ul><li>方法的形参是接口名。其实需要的是该接口的实现类对象</li><li>方法的返回值是接口名，其实返回的是该接口的实现类对象</li></ul><h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>本质就是文件夹，对类进行分类管理</p><h4 id="包得定义格式"><a href="#包得定义格式" class="headerlink" title="包得定义格式"></a>包得定义格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：package 包名；（多级包用.分开）</span><br><span class="line">范例：package com.itheima;</span><br></pre></td></tr></table></figure><h4 id="带包得java类编译和执行"><a href="#带包得java类编译和执行" class="headerlink" title="带包得java类编译和执行"></a>带包得java类编译和执行</h4><p>手动建包</p><ul><li><p>按照以前的格式编译Java文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java</span><br></pre></td></tr></table></figure></li><li><p>手动创建包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在E盘建立文件夹com，然后在com下建立文件夹itheima</span><br></pre></td></tr></table></figure></li><li><p>把calss文件放到包的最里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把HelloWorld.class文件放到com下的itheima这个文件夹下</span><br></pre></td></tr></table></figure></li><li><p>带包执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java com.itheima.HelloWorld</span><br></pre></td></tr></table></figure></li></ul><p>自动建包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d. HelloWorld.java</span><br></pre></td></tr></table></figure><h4 id="导包的概述和使用"><a href="#导包的概述和使用" class="headerlink" title="导包的概述和使用"></a>导包的概述和使用</h4><p>使用不同包下的类的时，使用的时候要写类的全路径，写的太麻烦了。为了简化带包的操作，Java就提供了导包的功能</p><p>导包格式</p><ul><li>格式：import 包名</li><li>范例：import cn.itcast,Teacher</li></ul><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><div class="table-container"><table><thead><tr><th>修饰符</th><th>同一个类中</th><th>同一个包中子类无关类</th><th>不同包的子类</th><th>不同包的无关类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td></td><td></td><td></td></tr><tr><td>默认</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table></div><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final关键字时最终的意思，可以修饰成员方法，成员变量，类</p><p>final修饰的特点</p><ul><li>修饰方法：表明该方法是最终方法，不能被重写</li><li>修饰变量：表明该变量时常量，不能被再次赋值</li><li>修饰类：表明该类是最终类，不能被继承</li></ul><p>final修饰局部变量</p><ul><li>变量是基本类型：final修饰指的是基本类型的数据值不能发生改变</li><li>变量是引用类型：final修饰指的是引用类型的地址值不能变，但是地址里面的内容是可以发生改变的</li></ul><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>static关键字是静态的意思，可以修饰成员方法，成员变量</p><p>static修饰的特点</p><ul><li>被类的所有对象共享（这也是我们判断是否使用静态关键字的条件）</li><li>可以通过类名调用（当然可以用对象名调用，推荐使用类名调用）</li></ul><p>static访问特点</p><p>非静态的成员方法</p><ul><li>能访问静态的成员变量</li><li>能访问非静态的成员变量</li><li>能访问静态的成员方法</li><li>能访问非静态的成员方法</li></ul><p>静态的成员方法（总结成一句话就是：静态成员方法只能访问静态成员）</p><ul><li>能访问静态的成员变量</li><li>能访问静态的成员方法</li></ul><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>就是在一个类中定义一个类。举例：在一个类A中定义一个类B，类B就被称为内部类</p><h4 id="内部类的访问特点"><a href="#内部类的访问特点" class="headerlink" title="内部类的访问特点"></a>内部类的访问特点</h4><ul><li>内部类可以直接访问外部类的成员，包括私有</li><li>外部类要访问内部类的成员，必须创建对象</li></ul><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>成员内部类，外界如何创建对象使用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：外部类名.内部类名 对象名 = 外部类名对象.内部类对象；</span><br><span class="line">范例：Outer.Inner oi = new Outer().new Inner();</span><br></pre></td></tr></table></figure><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>概述：局部内部类是在方法中的定义的类，所以外界是无法直接使用，需要在方法内部创建对象并使用，该类可以直接访问外部类的成员，也可以访问内部的局部变量</p><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>前提：存在一个类或接口，这里的类可以是具体类也可以是抽象类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">new 类名或接口名 ()&#123;</span><br><span class="line">重写方法；</span><br><span class="line">&#125;；</span><br><span class="line">范列：</span><br><span class="line">new Inter()&#123;</span><br><span class="line">public void show()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本质：是一个继承了该类或实现该接口的子类匿名对象</p><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>Math类的常用方法</p><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static int abs(int a)</td><td>返回参数的绝对值</td></tr><tr><td>public static double ceil(double a)</td><td>返回大于或等于参数的最double值，等于一个整数</td></tr><tr><td>public static double floor(double a)</td><td>返回小于或等于参数的最大double值，等于一个整数</td></tr><tr><td>public static int round(float a)</td><td>按照四舍五入返回最接近参数的int</td></tr><tr><td>public static int max(int a,int b)</td><td>返回两个int值中的较大值</td></tr><tr><td>public static int min(int a,int b)</td><td>返回两个int值中的较小值</td></tr><tr><td>public static double pow(double a,double b)</td><td>返回a的b次幂的值</td></tr><tr><td>public static double random()</td><td>返回值为double的正值，[0.0,1.0)</td></tr></tbody></table></div><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>概述：Object是类层次结构的根，每个类都可以将Object作为超类。所有类都直接或间接的继承自该类</p><p>构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Object()</span><br></pre></td></tr></table></figure><p>为什么说子类的构造方法默认访问的是父类的无参构造方法？</p><p>以为它们的顶级父类只有无参构造方法</p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><p>方法名：public String toString()</p><p>作用：返回对象的字符串表示形式。结果应该是一个简明扼要的表达，容易让人阅读。建议所有子类覆盖此方法,自动生成。</p><h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p>方法名：public booleaan equlas(Object obj)</p><p>作用：比较对象是否相等。默认比较地址，重写方法可以比较内容，推荐重写，自动生成。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>如果有n个数据进行排序，总共需要比较n-1次</li><li>每一次比较完毕，下一次的比较就会少一个数据参与</li></ul><h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p>Arrays类包含用于操作数组的各种方法</p><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static String toString(int[] a)</td><td>返回指定数组的内容的字符串表示形式</td></tr><tr><td>public static void sort(int[] a)</td><td>按照数字顺序排列指定数组</td></tr></tbody></table></div><p>工具类的设计思想：</p><ul><li>构造方法用private修饰</li><li>成员用public static修饰</li></ul><h3 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h3><p>概述：将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据</p><p>常用的操作之一：用于基本数据类型与字符串类型之间的转换</p><div class="table-container"><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table></div><h4 id="Integer类"><a href="#Integer类" class="headerlink" title="Integer类"></a>Integer类</h4><p>概述：Integer  包装一个对象中的原始数据类型int的值</p><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public Integer(int value)</td><td>根据int值创建个一integer对象（过时）</td></tr><tr><td>public Integer(String s)</td><td>根据String值创建Integer对象（过时）</td></tr><tr><td>public static Integer valueOf(int i)</td><td>返回表示指定的int值的integer实例</td></tr><tr><td>public static Integer valueOf(String s)</td><td>返回一个保存指定值的Integer对象String</td></tr></tbody></table></div><h4 id="int和String的相互转换"><a href="#int和String的相互转换" class="headerlink" title="int和String的相互转换"></a>int和String的相互转换</h4><p>基本类型包装类的最常见操作就是：用于基本类型和字符串之间的相互转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int转换为String</span><br><span class="line">public static String valueOf(int i)：返回int参数的字符串表示形式。该方法是String类中的方法</span><br><span class="line">String转换为int</span><br><span class="line">public static int parseInt(String s)：将字符串解析为int类型。该方法是Integer类中的方法</span><br></pre></td></tr></table></figure><h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h4><p>装箱：把基本数据类型转换为对应的包装类类型</p><p>拆箱：把包装类类型转换为对应的基本数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 100;  //自动装箱</span><br><span class="line">i += 200;         //i = i + 200; i + 200 自动拆箱；i = i + 200;是自动装箱</span><br></pre></td></tr></table></figure><p>注意：在使用包装类类型的时候，如果做操作，最好先判断是否为null，我们推荐的是，只要是对象，在使用前就必须进行不为null的判断</p><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>常用的方法</p><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public long getTime()</td><td>获取的是日期对象从1970年1月1日00:00:00到现在的毫秒</td></tr><tr><td>public void setTime(long time)</td><td>设置时间，给的是毫秒值</td></tr></tbody></table></div><h4 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h4><p>概述：SimpleFormat是个具体的类，用于以区域设置敏感的方式格式化和解析日期。</p><p>日期和时间格式由日期和时间模式字符串指定，在日期和时间模式字符串中，从‘A’到‘Z’以及从‘a’到’z’引号的字母被解释为表示日期或时间字符串的组件的模式字母</p><p>常用的模式字母及对应关系如下：</p><ul><li>y -年</li><li>M-月</li><li>d-日</li><li>H-时</li><li>m-分</li><li>s-秒</li></ul><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public SimpleDateFormat()</td><td>构造一个SimpleDateFormat,使用默认模式和日期格式</td></tr><tr><td>public SimpleDateFormat(String pattern)</td><td>构造一个SimpleDateFormat使用给定的模式和默认的日期格式</td></tr></tbody></table></div><h4 id="SimpleDateFormat格式化和解析日期"><a href="#SimpleDateFormat格式化和解析日期" class="headerlink" title="SimpleDateFormat格式化和解析日期"></a>SimpleDateFormat格式化和解析日期</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式化（从Date到String）</span><br><span class="line">public final String format(Date date):将日期格式化成日期/时间字符串</span><br><span class="line">解析（从String到Date）</span><br><span class="line">public Date parse(String source):从给定字符串的开始解析文本以生成日期</span><br></pre></td></tr></table></figure><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>概述：Calendar为某一时刻和一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法</p><p>Calendar提供了一个类方法getInstance用于获取Calendar对象，其日历字段已使用当前日历和时间初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar rightNow = Calendar,gerInstance();</span><br></pre></td></tr></table></figure><h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public int get(int field)</td><td>返回给定日历字段的值</td></tr><tr><td>public abstract void add(int field,int amount)</td><td>根据日历的规矩，将指定的时间两添加或减去给定的日历字段</td></tr><tr><td>public final void set(int year,int mouth,int date)</td><td>设置当前日历的年月日</td></tr></tbody></table></div><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>概述：就是成语出现了不正常的情况</p><p>异常体系：</p><p>Throwable</p><ul><li>Error</li><li>Exception<ul><li>RuntimeException</li><li>非RuntimeException</li></ul></li></ul><p>Error:严重问题，不需要处理</p><p>Exception:称为异常类，他表示程序本身可能可以处理的问题</p><ul><li>RuntimeException：在编译是不检查的，出现问题后，需要我们回来修改代码</li><li>非RuntimeException：编译期就必须处理的，否则程序不能通过编译，就更不能zhengchangyunxing了</li></ul><h4 id="JVM的默认处理方案"><a href="#JVM的默认处理方案" class="headerlink" title="JVM的默认处理方案"></a>JVM的默认处理方案</h4><p>如果程序出现了问题，我们没有做任何处理，最终JVM会做出默认的处理</p><ul><li>把异常的名称，异常原因及异常出现的位置等信息输入在了控制台</li><li>程序停止执行</li></ul><p>异常处理之 try…catch…</p><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">可能出现异常的代码;</span><br><span class="line">&#125;catch(异常类名 变量名)&#123;</span><br><span class="line">异常的处理代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><p>程序从try里的代码开始执行，出现异常，会自动生成一个异常对象，该异常对象将被提交给java运行时系统，当java运行时系统接受到异常对象时，会到catch中找匹配的异常类，找到后进行异常的处理，执行完毕之后，程序该可以继续往下执行</p><h4 id="Throwable的成员方法"><a href="#Throwable的成员方法" class="headerlink" title="Throwable的成员方法"></a>Throwable的成员方法</h4><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public String getMessage()</td><td>返回此throwable的详细消息字符串</td></tr><tr><td>public String toString()</td><td>返回此可抛出的简短描述</td></tr><tr><td>public void printStackTrace()</td><td>把异常的错误信息输出在控制台</td></tr></tbody></table></div><h4 id="编译时异常和运行时异常的区别"><a href="#编译时异常和运行时异常的区别" class="headerlink" title="编译时异常和运行时异常的区别"></a>编译时异常和运行时异常的区别</h4><p>java中的异常被分为两大类：编译时异常和运行时异常，也被称为受检异常和非受检异常，所有的RuntimeException类及其子类被称为运行时异常，其他的异常都是编译时异常</p><ul><li>编译时异常：必须显示处理，否则程序就会发生错误，无法通过编译</li><li>运行时异常：无需显示处理，也可以和编译时异常一样处理</li></ul><h4 id="异常处理之-throws"><a href="#异常处理之-throws" class="headerlink" title="异常处理之 throws"></a>异常处理之 throws</h4><p>虽然我们通过try..catch..可以对异常进行处理，但是并不是所有的情况都有权限进行异常的处理，也就是说，有些情况可能出现的异常是我们处理不了的，这个时间该怎么办呢？针对这种情况，Java提供了throws的处理方案</p><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throws 异常类名；</span><br></pre></td></tr></table></figure><p>注意：这个格式是跟在方法的括号后面的</p><ul><li>编译时异常必须要进行处理，两种处理方案：try…catch…或者throws，如果采用throws这种方案，将来谁调用谁处理</li><li>运行时异常可以不处理，出现问题后，需要我们回来修改代码</li></ul><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class 异常类名 Exception&#123;</span><br><span class="line">无参构造方法</span><br><span class="line">带参构造方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>范例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pubilc class ScoreExecption extends Exception&#123;</span><br><span class="line">public ScoreException()&#123;&#125;</span><br><span class="line">public ScoreException(String message)&#123;</span><br><span class="line">super(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>throws和throw的区别</p><div class="table-container"><table><thead><tr><th>throws</th><th>throw</th></tr></thead><tbody><tr><td>用在方法声明后面，跟的是异常类名</td><td>用在方法体内，跟的是异常对象名</td></tr><tr><td>表示抛出异常，由该方法的调用者来处理</td><td>表示抛出异常，有方法体内的语句处理</td></tr><tr><td>表示出现异常的一种可能性，并不一定会发生这些异常</td><td>执行throw一定抛出了某种yi’chan</td></tr></tbody></table></div><h3 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h3><h4 id="概述：-3"><a href="#概述：-3" class="headerlink" title="概述："></a>概述：</h4><p>是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值</p><p>Object类中有个方法可以获取对象的哈希值</p><ul><li>public int hashCode():返回对象的哈希值</li></ul><h4 id="对象的哈希值特点"><a href="#对象的哈希值特点" class="headerlink" title="对象的哈希值特点"></a>对象的哈希值特点</h4><ul><li>同一个对象多次调用hashCode()方法返回的哈希值是相同的</li><li>默认情况下，不同对象的哈希值是不同的，重写hashCode()方法，可以实现让不同对象的哈希值相同</li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>是参数化类型，也就是说所操作的数据类型被指定为一个参数</p><h4 id="泛型的定义格式："><a href="#泛型的定义格式：" class="headerlink" title="泛型的定义格式："></a>泛型的定义格式：</h4><ul><li>&lt;类型&gt;:指定一种类型的格式。这里的类型可以看成是型参</li><li>&lt;类型1，类型2….&gt;:指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成 是形参</li><li>将来具体调用时候给定的类型可以看成是形参，并且实参的类型只能是引用数据类型</li></ul><h4 id="泛型的好处："><a href="#泛型的好处：" class="headerlink" title="泛型的好处："></a>泛型的好处：</h4><ul><li>把运行时期的问题提前到了编译期间</li><li>避免了强制类型转换</li></ul><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：修饰符 class 类名  &lt;类型&gt;&#123;&#125;</span><br><span class="line">范例：public class Generic&lt;T&gt;&#123;&#125;</span><br><span class="line">此处T可以随便写为任意的标识，常见的如T,E,K,V等形式的参数常用于表示泛型</span><br></pre></td></tr></table></figure><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>定义格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：修饰符&lt;类型&gt;返回值类型 方法名(类名 变量名)&#123;&#125;</span><br><span class="line">范例：public &lt;T&gt; void show(T t)&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>定义格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：修饰符 interface 接口名&lt;类型&gt;&#123;&#125;</span><br><span class="line">范例：public interface Generic&lt;T&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h4><p>为了表示各种泛型List的父类，可以使用类型通配符</p><ul><li>类型通配符：&lt;?&gt;</li><li>List&lt;?&gt;:表示元素类型未知的List，它的元素可以匹配任何的类型</li><li>这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中</li></ul><p>如果说我们不希望List&lt;?&gt;是任何泛型List的父类，只希望它代表某一类泛型List的父类，可以使用类型通配符的上限</p><ul><li>类型通配符上限：&lt;? extends 类型&gt;</li><li>List&lt;? extends Number&gt;:它表示的类型是Number或者其父类型</li></ul><p>除了可以指定类型通配符的上限，我们也可以指定类型通配符的下限</p><ul><li>类型通配符下限：&lt;? super 类型&gt;</li><li>List&lt;?super Number&gt;:它表示的类型是Number或者其父类型</li></ul><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>概述：可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：修饰符 返回值类型 方法名（数据类型……变量名）&#123;&#125;</span><br><span class="line">范例：public static int sum(int... a)&#123;&#125;</span><br></pre></td></tr></table></figure><p>可变参数注意事项：</p><ul><li>这里的变量其实是一个数组</li><li>如果一个方法有多个参数，包含可变参数，可变参数要放在最后面</li></ul><p>可变参数的使用：</p><p>Arrays工具类中有个静态方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; asList(T... a)：返回由指定数组支持的固定大小的列表</span><br><span class="line">返回的集合不能做增删操作，可以做修改操作</span><br></pre></td></tr></table></figure><p>List接口中有一个静态方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt;List&lt;E&gt; of(E... elements):返回包含任意数量元素的不可变列表</span><br><span class="line">返回的集合不能做增删改操作</span><br></pre></td></tr></table></figure><p>Set接口中有一个静态方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt;Set&lt;E&gt; of(E...elements):返回一个包含任意数量元素的不可变集合</span><br><span class="line">在给元素的时候，不能给重复元素</span><br><span class="line">返回的集合不能做增删操作，没有修改的方法</span><br></pre></td></tr></table></figure><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>File：它是文件和目录路径名的抽象表示</p><ul><li>文件和目录是可以通过File封装成对象的</li><li>对于File而言，其封装的并不是一个正真存在的文件，仅仅是一个路径名而已，它可以是存在的，也可以是不存在的。将来是要通过具体操作把这个路径的内容转换为具体存在的</li></ul><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>File(String pathname)</td><td>通过将给定的路径名字符串转换为抽象路径名来创建新的File实例</td></tr><tr><td>File(String parent,String child)</td><td>从父路径名字符串和子路径名字字符串创建新的File实例</td></tr><tr><td>File(File parent,String child)</td><td>从父抽象路径名和子路径名字符串创建新的File实例</td></tr></tbody></table></div><h4 id="创建功能"><a href="#创建功能" class="headerlink" title="创建功能"></a>创建功能</h4><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean createNewFile()</td><td>当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件</td></tr><tr><td>public boolean mkdir()</td><td>创建由此抽象路径名命名的目录</td></tr><tr><td>public boolean mkdirs()</td><td>创建由此抽象路径命名的目录，包括任何必需但不存在的父目录</td></tr></tbody></table></div><h4 id="判断和获取功能"><a href="#判断和获取功能" class="headerlink" title="判断和获取功能"></a>判断和获取功能</h4><div class="table-container"><table><thead><tr><th>方法名</th><th>说名</th></tr></thead><tbody><tr><td>public boolean isDirectory()</td><td>测试此抽象路径名表示的File是否为目录</td></tr><tr><td>public boolean isFile()</td><td>测试此抽象路径名表示的File是否为文件</td></tr><tr><td>pubilc boolean exists()</td><td>测试此抽象路径名表示的File是否存在</td></tr><tr><td>public String getAbsolutePath()</td><td>返回此抽象路径名的绝对路径名字符串</td></tr><tr><td>public String getPath()</td><td>将此抽象路径名转换为路径名字符串</td></tr><tr><td>public String getName()</td><td>返回由此抽象路径名表示的文件或目录的名称</td></tr><tr><td>public String[] list()</td><td>返回此路径名表示的目录中的文件和目录的名称字符串数组</td></tr><tr><td>public File[] listFiles()</td><td>返回此抽象路径名表示的目录中文件和目录的File对象数组</td></tr></tbody></table></div><h4 id="File类删除功能"><a href="#File类删除功能" class="headerlink" title="File类删除功能"></a>File类删除功能</h4><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean delete()</td><td>删除由此抽象路径名表示的文件或目录</td></tr></tbody></table></div><p>绝对路径和相对路径的区别</p><ul><li>绝对路径：完整的路径名，不需要任何其他信息就可以定位它所表示的文件。例如：E://itcast//java.txt</li><li>相对路径：必须使用取自其他路径名的信息进行解释。例如：myFile//java.txt</li></ul><p>删除目录时的注意事项：</p><ul><li>如果一个目录中有内容（目录，文件），不能直接删除，应该先删除目录中的内容，最后才能删除目录</li></ul><h3 id="特殊操作流"><a href="#特殊操作流" class="headerlink" title="特殊操作流"></a>特殊操作流</h3><h4 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h4><p>System类中有两个静态的成员变量：</p><ul><li>public static final InputStream in:标准输入流。通常该流对应于键盘输入或主机环境或用户指定的另一个输入源</li><li>public static final PrintStream out:标准输出流。通常该流对应于显示输出或由主机环境或用户指定的另个输出目标</li></ul><p>自己实现键盘录入数据：</p><ul><li>BufferedReader br = new Bufferer(new InputStreamReader(System.in));</li></ul><p>写起来太麻烦了，java就提供了一个类实现键盘录入</p><ul><li>Scanner sc = new Scanner(System.in);</li></ul><p>输出语句的本质：是一个标准的输出流</p><ul><li>PrintStream ps = System.out;</li><li>PrintStream类有的方法，System.out都可以使用</li></ul><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>概述：是正在运行的程序</p><ul><li>是系统进行资源分配和调用的独立单位</li><li>每一个进程都有它自己的内存空间和系统资源</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>概叙：</p><p>是进程中的单个顺序控制流，是一条执行路径</p><ul><li>单线程：一个进程如果只有一条执行路径，则称为单线程程序</li><li>多线程：一个进程如果有多条执行路径，则称为多线程程序</li></ul><h4 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h4><p>方法一：继承Thread类</p><ul><li>定义一个类MyThread继承Thread类</li><li>在MyThread类中重写run()方法</li><li>创建MyThread类对象</li><li>启动线程</li></ul><p>方法二：实现Runnable接口</p><ul><li>定义一个类MyRunable实现Runnable接口</li><li>在MyRunnable类中重写run()方法</li><li>创建MyRunnable类的对象</li><li>创建Thread类的对象，把MyRunnable对象作为构造方法的参数</li><li>启动线程</li></ul><p>多线程的实现方案有两种</p><ul><li>继承Thread类</li><li>实现Runnable接口</li></ul><p>相比继承Thread类，实现Runnable接口的好处</p><ul><li>避免了Java单继承的局限性</li><li>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想</li></ul><p>两个小问题</p><ul><li><p>为什么要重写run()方法？</p><p>因为run()用来封装被线程执行的代码</p></li><li><p>run()方法和statrt()方法的区别</p><p>run():封装线程执的代码，直接调用，相当于普通方法的调用</p><p>start():启动线程，然后由JVM调用此线程的run()方法</p></li></ul><h4 id="设置和获取线程名称"><a href="#设置和获取线程名称" class="headerlink" title="设置和获取线程名称"></a>设置和获取线程名称</h4><p>Thread类中设置和获取线程名称的方法</p><ul><li>void setName(String name):将此线程的名称更改为等于参数name</li><li>String getName():返回此线程的名称</li></ul><p>如何获取main()方法所在的线程的名称？</p><ul><li>public static Thread currentThread()返回对当前正在执行的线程对象的引用</li></ul><h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>线程有两种调度模型</p><ul><li>分时间模型：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片</li><li>抢占式调度模型：优先让优先级高的线程使用cpu，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的cpu时间片相对多一些</li></ul><p>java使用的是抢占式调都模型</p><p>假如计算机只有一个CPU，那么CPU在某个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁强到CPU的使用权是不一样的</p><p>Thread类中设置和获取线程优先级的方法</p><ul><li>public final int getPriority():返回此线程的优先级</li><li>public final void setPriority(int newPriority):更改此线程的优先级</li></ul><p>线程默认优先级是5；线程优先级的范围是：1-10</p><p>线程优先级高级仅仅表示获取的CPU时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到你想要的效果</p><h4 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h4><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>static void sleep(long millis)</td><td>使当前正在执行的线程停留（暂停执行）指定的毫秒数</td></tr><tr><td>void join()</td><td>等待这个线程死亡</td></tr><tr><td>void setDaemon(boolean on)</td><td>将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出</td></tr></tbody></table></div><h4 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h4><p>要点：</p><ul><li>由新建，就绪，运行或堵塞，死亡组成</li><li>start()使线程具有执行资格</li><li>抢到CPU的线程具有执行权</li><li>sleep()可以堵塞线程</li></ul><h4 id="数据安全问题"><a href="#数据安全问题" class="headerlink" title="数据安全问题"></a>数据安全问题</h4><p>为什么出现问题？（这也就是判断多线程是否会出现数据安全问题的标准）</p><ul><li>是否是多线程环境</li><li>是否有共享数据</li><li>是否有多条语句操作共享数据</li></ul><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><p>锁定多条语句操作共享数据，可以使用同步代码块实现</p><ul><li><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronrized(任意对象)&#123;</span><br><span class="line">多条语句操作共享数据的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>synchronized(任意对象):就相当于给代码加锁了，任意对象就可以看成是一把锁</p></li></ul><p>同步的好处和弊端</p><ul><li>好处：解决了多线程的数据安全问题</li><li>弊端：当线程很多时，因为每个线程都会去判断同步上锁，这是很耗费资源的，无形中会降低程序的运行效率</li></ul><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>同步方法：就是把synchronized关键字加到方法上</p><ul><li><p>格式：</p><p>修饰符 synchronized 返回值类型 方法名（方法参数）{}</p></li></ul><p>同步方法的锁对象时什么呢？</p><ul><li>this</li></ul><p>同步静态方法：就是把synchronized</p><ul><li><p>格式：</p><p>修饰符 static synchronized 返回值类型 方法名（方法参数）{}</p></li></ul><p>同步静态方法的锁对象时什么呢？</p><ul><li>类名.class</li></ul><h4 id="线程安全的类"><a href="#线程安全的类" class="headerlink" title="线程安全的类"></a>线程安全的类</h4><p>StringBuffer</p><ul><li>线程安全，可变的字符序列</li><li>从版本JDK5开始，被StringBuilder替代。通常应该使用StringBuilder类，因为它支持所有相同的操作，但它更快，因为它不执行同步</li></ul><p>Vector</p><ul><li>从Java2平台v1.2开始，该类改进了List接口，使其成为Java CollectionsFramework的成员，与新的集合实现不同，Vector被同步。如果不需要线程安全的实现，建议使用ArrayList代替Vertor</li></ul><p>Hashtable</p><ul><li>给类实现了一个哈希表，它将键映射到值。任何非null对象都可以用作键或者值</li><li>从java2平台v1.2开始，该类进行了改进，实现了Map接口，使其成为Java Collections Framework的成员。与新的集合实现不同，Hashtable被同步。如果不需要线程安全的实现，建议使用HashMap替代Hashtable</li></ul><h4 id="Look锁"><a href="#Look锁" class="headerlink" title="Look锁"></a>Look锁</h4><p>虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到哪里加了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock</p><p>Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作</p><p>Lock中提供了获得锁和释放锁的方法</p><ul><li>void lock():获得锁</li><li>void unlock():释放锁</li></ul><p>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化</p><p>ReentrantLock的构造方法</p><ul><li>ReentrantLock():创建一个ReentrantLock的实例</li></ul><h4 id="生产者消费者模式概述"><a href="#生产者消费者模式概述" class="headerlink" title="生产者消费者模式概述"></a>生产者消费者模式概述</h4><p>为了体现生产和消费过程中的等待和唤醒，Java就提供了几个方法供我们使用，值几个方法在Object类中</p><p>Object类的等待和唤醒方法：</p><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void wait()</td><td>导致当前线程等待，直到另一个线程调用对象的notify()方法或者notifyAll()方法</td></tr><tr><td>void notify()</td><td>唤醒正在等待对象监视器的单个线程</td></tr><tr><td>void notifyAll()</td><td>唤醒正在等待对象监视器的所有线程</td></tr></tbody></table></div><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><h4 id="字符串的分割"><a href="#字符串的分割" class="headerlink" title="字符串的分割"></a>字符串的分割</h4><p>Java 提供了多种方法来分割字符串。最常用的是使用 <code>String.split()</code> 方法。</p><p>以下是一些示例:</p><p>使用空格分割字符串:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">String[] words = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">// words 数组包含 [&quot;Hello&quot;, &quot;World&quot;]</span></span><br></pre></td></tr></table></figure><p>使用逗号分割字符串:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;apple,banana,cherry&quot;</span>;</span><br><span class="line">String[] fruits = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="comment">// fruits 数组包含 [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]</span></span><br></pre></td></tr></table></figure><p>使用正则表达式分割字符串:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Java-Python-C++&quot;</span>;</span><br><span class="line">String[] languages = str.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="comment">// languages 数组包含 [&quot;Java&quot;, &quot;Python&quot;, &quot;C++&quot;]</span></span><br></pre></td></tr></table></figure><p>限制分割的最大数量:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;one two three four&quot;</span>;</span><br><span class="line">String[] parts = str.split(<span class="string">&quot; &quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// parts 数组包含 [&quot;one&quot;, &quot;two three four&quot;]</span></span><br></pre></td></tr></table></figure><p>在上面的例子中,<code>str.split(&quot; &quot;, 2)</code> 表示最多分割成 2 个部分,即第一个空格之前的部分和剩余的部分。</p><p>总之,<code>String.split()</code> 方法提供了很大的灵活性,可以根据需要使用不同的分隔符或正则表达式来分割字符串。这是 Java 中非常常用的字符串操作技巧。</p>]]></content>
      
      
      <categories>
          
          <category> 编程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;  }    div#menus {    font-family: "ZhuZiAYuanJWD";  }  h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;  }  a.article-title,  a.blog-slider__title,  a.categoryBar-list-link,  h1.post-title {    font-family: ZhuZiAYuanJWD;  }    .iconfont {    font-family: "iconfont" !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;  }    /* 时间轴生肖icon */  svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;  }    .icon-zhongbiao::before {    color: #f7c768;  }    /* bilibli番剧插件 */  #article-container .bangumi-tab.bangumi-active {    background: var(--anzhiyu-theme);    color: var(--anzhiyu-ahoverbg);    border-radius: 10px;  }  a.bangumi-tab:hover {    text-decoration: none !important;  }  .bangumi-button:hover {    background: var(--anzhiyu-theme) !important;    border-radius: 10px !important;    color: var(--anzhiyu-ahoverbg) !important;  }  a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;  }  .bangumi-button {    padding: 5px 10px !important;  }    a.bangumi-tab {    padding: 5px 10px !important;  }  svg.icon.faa-tada {    font-size: 1.1em;  }  .bangumi-info-item {    border-right: 1px solid #f2b94b;  }  .bangumi-info-item span {    color: #f2b94b;  }  .bangumi-info-item em {    color: #f2b94b;  }    /* 解决artitalk的图标问题 */  #uploadSource > svg {    width: 1.19em;    height: 1.5em;  }    /*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */  #page-header:not(.not-top-img):before {    background-color: transparent !important;  }    /* 首页文章卡片 */  #recent-posts > .recent-post-item {    background: rgba(255, 255, 255, 0.9);  }    /* 首页侧栏卡片 */  #aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);  }    /* 文章页面正文背景 */  div#post {    background: rgba(255, 255, 255, 0.9);  }    /* 分页页面 */  div#page {    background: rgba(255, 255, 255, 0.9);  }    /* 归档页面 */  div#archive {    background: rgba(255, 255, 255, 0.9);  }    /* 标签页面 */  div#tag {    background: rgba(255, 255, 255, 0.9);  }    /* 分类页面 */  div#category {    background: rgba(255, 255, 255, 0.9);  }    /*夜间模式伪类遮罩层透明*/  [data-theme="dark"] #recent-posts > .recent-post-item {    background: #121212;  }    [data-theme="dark"] .card-widget {    background: #121212 !important;  }    [data-theme="dark"] div#post {    background: #121212 !important;  }    [data-theme="dark"] div#tag {    background: #121212 !important;  }    [data-theme="dark"] div#archive {    background: #121212 !important;  }    [data-theme="dark"] div#page {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: transparent !important;  }  /* 页脚透明 */  #footer {    background: transparent !important;  }    /* 头图透明 */  #page-header {    background: transparent !important;  }    #rightside > div > button {    border-radius: 5px;  }    /* 滚动条 */    ::-webkit-scrollbar {    width: 10px;    height: 10px;  }    ::-webkit-scrollbar-thumb {    background-color: #3b70fc;    border-radius: 2em;  }    ::-webkit-scrollbar-corner {    background-color: transparent;  }    ::-moz-selection {    color: #fff;    background-color: #3b70fc;  }    /* 音乐播放器 */    /* .aplayer .aplayer-lrc {    display: none !important;  } */    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */  }    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */  }    .aplayer.aplayer-fixed {    z-index: 999999 !important;  }    /* 评论框  */  .vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;  }    /* 设置评论框 */    .vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;  }    /* md网站下划线 */  #article-container a:hover {    text-decoration: none !important;  }    #article-container #hpp_talk p img {    display: inline;  }    /* 404页面 */  #error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);  }    #error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;  }    #error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;  }    #error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;  }  #error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;  }  #error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;  }  #error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);  }    #body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;  }    #body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;  }    #body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;  }    #body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;  }    #body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;  }    #body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;  }    #body-wrap.error .aside-list .aside-list-item .content time {    display: none;  }    /* 代码框主题 */  #article-container figure.highlight {    border-radius: 10px;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"孤城一豪&blog","short_name":"愚夫","theme_color":"#3b70fc","background_color":"#3b70fc","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/头像.jpeg","sizes":"16x16","type":"image/png"},{"src":"/img/头像.jpeg","sizes":"32x32","type":"image/png"},{"src":"/img/头像.jpeg","sizes":"48x48","type":"image/png"},{"src":"/img/头像.jpeg","sizes":"64x64","type":"image/png"},{"src":"/img/头像.jpeg","sizes":"128x128","type":"image/png"},{"src":"/img/头像.jpeg","sizes":"144x144","type":"image/png"},{"src":"/img/头像.jpeg","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
