<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>黑马程序员java自学笔记（包括Java环境配置与IDEA的下载地址） | 孤城一豪&amp;blog</title><meta name="author" content="愚夫"><meta name="copyright" content="愚夫"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="java学习的开始环境的搭建请参考如下文章： 【Java】java 环境配置(详细教程)_java配置环境教程-CSDN博客 常用的DOS命令： 按下win+R 输入cmd      操作 说明     盘符名称： 盘符切换。E:回车，表示切换到E盘   dir 查看当前路径下的内容   cd 目录 进入单级目录   cd.. 退回到上级目录   cd 目录1\目录2 \ … 进入多级目录   c">
<meta property="og:type" content="article">
<meta property="og:title" content="黑马程序员java自学笔记（包括Java环境配置与IDEA的下载地址）">
<meta property="og:url" content="https://yufusir.github.io/posts/4454963.html">
<meta property="og:site_name" content="孤城一豪&amp;blog">
<meta property="og:description" content="java学习的开始环境的搭建请参考如下文章： 【Java】java 环境配置(详细教程)_java配置环境教程-CSDN博客 常用的DOS命令： 按下win+R 输入cmd      操作 说明     盘符名称： 盘符切换。E:回车，表示切换到E盘   dir 查看当前路径下的内容   cd 目录 进入单级目录   cd.. 退回到上级目录   cd 目录1\目录2 \ … 进入多级目录   c">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/66b21119d9c307b7e9f5da19.jpg">
<meta property="article:published_time" content="2024-05-18T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-19T16:35:26.168Z">
<meta property="article:author" content="愚夫">
<meta property="article:tag" content="编程语言">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/66b21119d9c307b7e9f5da19.jpg"><link rel="shortcut icon" href="/img/%E5%A4%B4%E5%83%8F.jpeg"><link rel="canonical" href="https://yufusir.github.io/posts/4454963.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="#3b70fc"/><link rel="apple-touch-icon" sizes="180x180" href="/img/%E5%A4%B4%E5%83%8F.jpeg"/><link rel="icon" type="image/png" sizes="32x32" href="/img/%E5%A4%B4%E5%83%8F.jpeg"/><link rel="icon" type="image/png" sizes="16x16" href="/img/%E5%A4%B4%E5%83%8F.jpeg"/><link rel="mask-icon" href="/img/%E5%A4%B4%E5%83%8F.jpeg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 愚夫","link":"链接: ","source":"来源: 孤城一豪&blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '黑马程序员java自学笔记（包括Java环境配置与IDEA的下载地址）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-20 00:35:26'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="孤城一豪&blog" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/center-atom.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-heart"></i><span> 宝藏番</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic.imgdb.cn/item/66b21119d9c307b7e9f5da19.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="孤城一豪&amp;blog"><span class="site-name">孤城一豪&amp;blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-heart"></i><span> 宝藏番</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">黑马程序员java自学笔记（包括Java环境配置与IDEA的下载地址）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-18T16:00:00.000Z" title="发表于 2024-05-19 00:00:00">2024-05-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-19T16:35:26.168Z" title="更新于 2024-08-20 00:35:26">2024-08-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">编程笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="黑马程序员java自学笔记（包括Java环境配置与IDEA的下载地址）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="java学习的开始"><a href="#java学习的开始" class="headerlink" title="java学习的开始"></a>java学习的开始</h3><h4 id="环境的搭建"><a href="#环境的搭建" class="headerlink" title="环境的搭建"></a>环境的搭建</h4><p>请参考如下文章：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011397981/article/details/129495097">【Java】java 环境配置(详细教程)_java配置环境教程-CSDN博客</a></p>
<h4 id="常用的DOS命令："><a href="#常用的DOS命令：" class="headerlink" title="常用的DOS命令："></a>常用的DOS命令：</h4><ul>
<li>按下win+R</li>
<li>输入cmd</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>盘符名称：</td>
<td>盘符切换。E:回车，表示切换到E盘</td>
</tr>
<tr>
<td>dir</td>
<td>查看当前路径下的内容</td>
</tr>
<tr>
<td>cd 目录</td>
<td>进入单级目录</td>
</tr>
<tr>
<td>cd..</td>
<td>退回到上级目录</td>
</tr>
<tr>
<td>cd 目录1\目录2 \ …</td>
<td>进入多级目录</td>
</tr>
<tr>
<td>cd\</td>
<td>退回到盘符目录</td>
</tr>
<tr>
<td>cls</td>
<td>清屏</td>
</tr>
<tr>
<td>exit</td>
<td>退出命令提示符窗口</td>
</tr>
</tbody>
</table>
</div>
<h4 id="HelloWorld案例"><a href="#HelloWorld案例" class="headerlink" title="HelloWorld案例"></a>HelloWorld案例</h4><ul>
<li><p>新建一个文本文档文件，修改名称为HelloWorld.java</p>
</li>
<li><p>用记事本打开HelloWorld.java文件，输入程序内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		System.out.println(&quot;HelloWorld&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;//保存文件Crtl + s</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开命令提示符窗口，进入HelloWorld.java所在的目录。输入指令编译和执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编译：javac 文件名.java</span><br><span class="line">范例：javac HelloWorld.java</span><br><span class="line"></span><br><span class="line">执行：java 类名</span><br><span class="line">范例: java Hello World</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="编译工具的下载："><a href="#编译工具的下载：" class="headerlink" title="编译工具的下载："></a>编译工具的下载：</h4><p><a target="_blank" rel="noopener" href="https://www.jetbrains.com/idea/download/other.html">Other Versions - IntelliJ IDEA (jetbrains.com)</a> </p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>概述：</p>
<p>方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集</p>
<p>注意：</p>
<ul>
<li>方法必须先创建才能使用，该过程成为方法的定义</li>
<li>方法创建后并不是直接使用，需要手动使用后才会执行，该过程成为方法的调用</li>
</ul>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>构造方法是一个特殊的方法（方法名为类名的方法）</p>
<p>作用：创建对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">public class 类名&#123;</span><br><span class="line">	修饰符 类名（参数）&#123;</span><br><span class="line">	//注意：如果使用带参的构造方法，必须先创一个无参的构造方法</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能：主要是完成对象数据的初始化</p>
<h4 id="构造方法的注意事项"><a href="#构造方法的注意事项" class="headerlink" title="构造方法的注意事项"></a>构造方法的注意事项</h4><p>构造方法的创建</p>
<ul>
<li>如果没有定义构造方法，系统将会给一个默认的无参构造方法</li>
<li>如果定义了构造方法，系统将不会提供默认的构造方法</li>
</ul>
<p>构造方法的重载</p>
<ul>
<li>如果定义了带参构造方法，还要使用无参构造方法，就必须再写一个无参构造方法</li>
</ul>
<p>推荐的使用方式</p>
<ul>
<li>无论是否使用，都手工书写无参构造方法</li>
</ul>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="什么是对象："><a href="#什么是对象：" class="headerlink" title="什么是对象："></a>什么是对象：</h4><p>万物皆为对象，客观存在的事物都是对象</p>
<h4 id="什么是类："><a href="#什么是类：" class="headerlink" title="什么是类："></a>什么是类：</h4><p>类是对现实生活中一类具有共同属性和行为的事物的抽象</p>
<h4 id="类的特点："><a href="#类的特点：" class="headerlink" title="类的特点："></a>类的特点：</h4><ul>
<li>类是对象的数据类型</li>
<li>类是具有相同属性和行为的一组对象的集合</li>
</ul>
<h4 id="什么是对象的属性"><a href="#什么是对象的属性" class="headerlink" title="什么是对象的属性"></a>什么是对象的属性</h4><p>属性：</p>
<p>对象具有的各种特征，每个对象的每个属性都拥有特定的值</p>
<h4 id="什么是对象的行为"><a href="#什么是对象的行为" class="headerlink" title="什么是对象的行为"></a>什么是对象的行为</h4><p>行为：</p>
<p>对象能够执行的操作</p>
<h4 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h4><p>类是对象的抽象，对象是类的实体</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;数据类型&gt; 对象 = new ArrayList&lt;&gt;()</span><br></pre></td></tr></table></figure>
<h4 id="添加方法-E-e是元素的意思"><a href="#添加方法-E-e是元素的意思" class="headerlink" title="添加方法(E e是元素的意思)"></a>添加方法(E e是元素的意思)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e);</span><br><span class="line">将指定的元素追加到此集合的末尾</span><br><span class="line">public void add(int index,E element);</span><br><span class="line">在此集合中指定位置插入指定元素</span><br><span class="line">public booleam remove(Object o);</span><br><span class="line">删除指定元素，返回删除是否成功</span><br><span class="line">public E remove(int index);</span><br><span class="line">删除指定索引处的元素，返回被删除的元素</span><br><span class="line">public E set(int index,E element);</span><br><span class="line">修改指定位置的元素，返回被修改的元素</span><br><span class="line">public E get(int index);</span><br><span class="line">返回指定索引处元素</span><br><span class="line">public int size();</span><br><span class="line">返回集合元素的个数</span><br></pre></td></tr></table></figure>
<h3 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h3><h4 id="特有功能（方法）"><a href="#特有功能（方法）" class="headerlink" title="特有功能（方法）"></a>特有功能（方法）</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public void addFirst(E e)</td>
<td>在该列表开头插入指定的元素</td>
</tr>
<tr>
<td>public void addLast(E e)</td>
<td>将指定的元素追加到此列表的末尾</td>
</tr>
<tr>
<td>public E getFirst()</td>
<td>返回此列表中的第一个元素</td>
</tr>
<tr>
<td>public E getLast()</td>
<td>返回此列表中最后一个元素</td>
</tr>
<tr>
<td>public E removeFirst()</td>
<td>从此列表中删除并返回第一个元素</td>
</tr>
<tr>
<td>public E removeLast()</td>
<td>从此列表中删除并返回最后一个元素</td>
</tr>
</tbody>
</table>
</div>
<h3 id="LinkedHashSet集合"><a href="#LinkedHashSet集合" class="headerlink" title="LinkedHashSet集合"></a>LinkedHashSet集合</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>哈希表和链表实现的Set接口，具有可预测的迭代次序</li>
<li>由链表保证元素有序，也就是说元素的存储和取出顺序是一致的</li>
<li>由哈希表保证元素唯一，也就是说没有重复的元素</li>
</ul>
<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>不包含重复元素的集合</li>
<li>没有带索引的方法，所以不能使用普通for循环遍历</li>
</ul>
<h4 id="HashSet-集合"><a href="#HashSet-集合" class="headerlink" title="HashSet()集合"></a>HashSet()集合</h4><p>HashSet集合特点</p>
<ul>
<li>底层数据结构是哈希表</li>
<li>对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致</li>
<li>没有索引的方法，所以不能使用普通for循环遍历</li>
<li>由于是Set集合，所以是不包含重复元素的集合</li>
</ul>
<p>HashSet集合保证元素唯一性源码分析（太多了，也不是特别重要，自己了解）</p>
<h4 id="TreeSet集合"><a href="#TreeSet集合" class="headerlink" title="TreeSet集合"></a>TreeSet集合</h4><p>特点：</p>
<ul>
<li>元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方式取决于构造方法<ul>
<li>TreeSet():根据去元素的自然排序进行排序</li>
<li>TreeSet(Comparator comparator):根据指定的比较器进行排序</li>
</ul>
</li>
<li>没有带索引的方法，所以不能使用普通for循环遍历</li>
<li>由于是Set集合，所以不包含重复元素的集合</li>
</ul>
<h4 id="自然排序Comparable的使用"><a href="#自然排序Comparable的使用" class="headerlink" title="自然排序Comparable的使用"></a>自然排序Comparable的使用</h4><ul>
<li>用TreeSer集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的</li>
<li>自然排序，就是让元素所属的类实现Comparable接口，重写comparaTo(T o)方法</li>
<li>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</li>
</ul>
<h4 id="比较器排序Comparator的使用"><a href="#比较器排序Comparator的使用" class="headerlink" title="比较器排序Comparator的使用"></a>比较器排序Comparator的使用</h4><ul>
<li>用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的</li>
<li>比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compara(T o1,T o2)方法</li>
<li>重写方法时，一定要注意排序规则必须按照要求的主要要求和次要条件来来写</li>
</ul>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="Collection集合概述："><a href="#Collection集合概述：" class="headerlink" title="Collection集合概述："></a>Collection集合概述：</h4><ul>
<li>是单例集合的顶层接口，他表示一组对象，这些对象也称为Collection的元素</li>
<li>JDK不提供此接口的任何直接实现，他提供更具体的子接口（如Set和List）实现</li>
</ul>
<h4 id="创建Collection集合的对象"><a href="#创建Collection集合的对象" class="headerlink" title="创建Collection集合的对象"></a>创建Collection集合的对象</h4><ul>
<li>多态的方式</li>
<li>具体的实现类ArrayList</li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean add(E e)</td>
<td>添加元素</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td>从集合中移除指定的元素</td>
</tr>
<tr>
<td>void clear()</td>
<td>清空集合中的元素</td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td>判断集合中是否存在指定的元素</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td>in size()</td>
<td>集合的长度，也就是集合中的元素的个数</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Collection集合的遍历"><a href="#Collection集合的遍历" class="headerlink" title="Collection集合的遍历"></a>Collection集合的遍历</h4><p>Iterator</p>
<ul>
<li>Iterator<E>iterator():返回此集合中元素的迭代器，通过集合的iterator()方法得到</li>
<li>迭代器是通过集合的iterator()方法得到的，所以我们说它是依赖于集合而存在的</li>
</ul>
<p>Iterator中的常用方法</p>
<ul>
<li>E next()：返回迭代中的下一个元素</li>
<li>boolean hasNext()：如果迭代具有更多元素，则返回true</li>
</ul>
<h3 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>是针对集合操作的工具类</p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;?super T&gt;&gt; void sort(List&lt;T&gt; list)</span><br><span class="line">将指定的列表按升序排序</span><br><span class="line">public static void reverse(List&lt;?&gt;list)</span><br><span class="line">反转指定列表中元素的顺序</span><br><span class="line">public static void shuffle(List&lt;?&gt;list)</span><br><span class="line">使用默认的随机源随机排列指定的列表</span><br></pre></td></tr></table></figure>
<h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><p>概述：</p>
<ul>
<li>有序集合（也称为序列），用户可以精确控制列表中的每个元素的插入位置。用户可以通过整数索引访问元素，并搜索元素</li>
<li>与Set集合不同，列表通常允许重复的元素</li>
</ul>
<p>List集合特点</p>
<ul>
<li>有序：存储和取出的元素顺序一致</li>
<li>可重复：存储的元素可以重复</li>
</ul>
<h4 id="List集合特有方法"><a href="#List集合特有方法" class="headerlink" title="List集合特有方法"></a>List集合特有方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void add(int index,E element)</td>
<td>在此集合中的指定位置插入指定的元素</td>
</tr>
<tr>
<td>E remove(int index)</td>
<td>删除指定索引处的元素，返回被删除的元素</td>
</tr>
<tr>
<td>E set(int index,E element)</td>
<td>修改指定索引处的元素，返回被修改的元素</td>
</tr>
<tr>
<td>E get(int index)</td>
<td>返回指定索引处的元素</td>
</tr>
</tbody>
</table>
</div>
<h4 id="并发修改异常-ConcurrentModificationException"><a href="#并发修改异常-ConcurrentModificationException" class="headerlink" title="并发修改异常(ConcurrentModificationException)"></a>并发修改异常(ConcurrentModificationException)</h4><p>产生原因：</p>
<p>迭代器遍历的过程中，通过集合对象修改了集合中元素的长度，造成了迭代器获取元素中判断预期修改值和实际修改值不一致</p>
<p>解决方案：</p>
<p>用for循环遍历，然后用集合对象做对应的操作即可</p>
<h4 id="ListIterator-列表迭代器"><a href="#ListIterator-列表迭代器" class="headerlink" title="ListIterator(列表迭代器)"></a>ListIterator(列表迭代器)</h4><p>作用：</p>
<ul>
<li>通过List集合的listIterator()方法得到，所以说它是List集合特有的迭代器</li>
<li>用于允许程序员沿任意方向遍历列表的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置</li>
</ul>
<p>ListIterator中常用方法：</p>
<ul>
<li>E next();返回迭代中的下一个元素</li>
<li>boolean hasNext();如果迭代具有更多元素，则返回true</li>
<li>E previous();返回列表中上一个元素</li>
<li>boolean hasPrevious();如果此列表迭代器在相反方向遍历列表时具有更对元素，则返回true</li>
<li>void add(E e);指定的元素插入列表  </li>
</ul>
<h4 id="List集合子类特点"><a href="#List集合子类特点" class="headerlink" title="List集合子类特点"></a>List集合子类特点</h4><p>常用子类：ArrayList，LinkedList</p>
<ul>
<li>Array List：底层数据结构是数组，查询快，增删慢</li>
<li>LinkedList：底层数据结构是链表，查询慢，增删快</li>
</ul>
<h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><p>概述：</p>
<ul>
<li>Interface Map<k,V> K:键的类型 V:值的类型</li>
<li>将键映射到值的对象：不能包含重复的键：每个键可以映射到最多一个值</li>
<li>举例： 学生的学号（键）和姓名（值）</li>
</ul>
<h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>V put (K key,V value)</td>
<td>添加元素</td>
</tr>
<tr>
<td>V remove(Object key)</td>
<td>根据键删除键值对元素</td>
</tr>
<tr>
<td>void clear()</td>
<td>移除所有的键值对元素</td>
</tr>
<tr>
<td>boolean containsKey(Object key)</td>
<td>判断集合是否包含指定的键</td>
</tr>
<tr>
<td>boolean containsValue(Object value)</td>
<td>判断集合是否包含指定的值</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td>int size()</td>
<td>集合的长度，也就是集合中键值对的个数</td>
</tr>
</tbody>
</table>
</div>
<h4 id="获取功能"><a href="#获取功能" class="headerlink" title="获取功能"></a>获取功能</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>V get(Object key)</td>
<td>根据键获取值</td>
</tr>
<tr>
<td>Set<K> keySet()</td>
<td>获取所有键的集合</td>
</tr>
<tr>
<td>Collection<V>values()</td>
<td>获取所有值的集合</td>
</tr>
<tr>
<td>Set<Map.Entry<K,V>&gt;entrySet()</td>
<td>获取所有键值对对象的集合</td>
</tr>
</tbody>
</table>
</div>
<h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><ul>
<li>简化了数组和Collection集合的遍历</li>
<li>实现了Iterable接口的类允许其对象成为增强型for语句的目标</li>
<li>它是JDK5之后出现的，其内部原理是一个Iterator迭代器</li>
</ul>
<h4 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h4><p>for(元素数据类型 变量名：数组或者Collection集合){</p>
<p>//在此处使用变量即可，该变量就是元素</p>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">范例：</span><br><span class="line">int[] arr = &#123;1,2,3,4,5&#125;;</span><br><span class="line">for(int i:arr)&#123;</span><br><span class="line">	System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="概述：-1"><a href="#概述：-1" class="headerlink" title="概述："></a>概述：</h4><p>数据结构是计算机存储、组织数据的方式。是指相互之间存在一种或多种特定关系的数据元素的集合（通常情况下，精心选择的数据结构可以带来更高的运行或着存储效率）</p>
<h4 id="常见数据结构之栈"><a href="#常见数据结构之栈" class="headerlink" title="常见数据结构之栈"></a>常见数据结构之栈</h4><p>栈是一种数据先进后出的数据模型，有栈顶元素和栈低元素</p>
<p>数据进入栈模型的过程称为：压/进栈</p>
<p>数据离开栈模型的过程称为：弹/出栈</p>
<h4 id="常见数据结构之队列"><a href="#常见数据结构之队列" class="headerlink" title="常见数据结构之队列"></a>常见数据结构之队列</h4><p>队列是一种数据先进先出的模型，入队列方向为后端，出队列方向为前端</p>
<p>数据从后端进入队列模式的过程称为：入队列</p>
<p>数据从前端离开队列模型的过程称为：出队列</p>
<h4 id="常见数据结构之数组"><a href="#常见数据结构之数组" class="headerlink" title="常见数据结构之数组"></a>常见数据结构之数组</h4><p>概述：数组是一种查询快，增删慢的模型</p>
<ul>
<li>查询数据通过索引定位，查询任意数据耗时相同，<strong>查询效率高</strong></li>
<li>删除数据时，要将原始数据删除，同时后面每个数据前移，<strong>删除数据效率低</strong></li>
<li>添加数据是，添加位置后的每个数据后移，在添加元素，<strong>添加效率极低</strong></li>
</ul>
<h4 id="常见数据结构之链表"><a href="#常见数据结构之链表" class="headerlink" title="常见数据结构之链表"></a>常见数据结构之链表</h4><p>概述：有头结点，有结点，结点由数据（是存储具体的数据，也是这个结点的存储位置）和地址（下个结点的地址）构成，头结点由head和^(指空地址，节点指向空地址表示结束)</p>
<p>特点：</p>
<p>链表是一种增删快的模型（对比数组）</p>
<p>链表是一种查询慢的模型（对比数组）</p>
<h4 id="常见数据结构之哈希表"><a href="#常见数据结构之哈希表" class="headerlink" title="常见数据结构之哈希表"></a>常见数据结构之哈希表</h4><p>概述：JDK8之前，底层采用数据+链表实现，可以说是一个元素为链表的数组，JDK8以后，在长度比较长的时候，底层实现了优化</p>
<p>如何存储数据：</p>
<p>哈希表默认由16个单位容量（0-15），然后将存储的数据的哈希值对16取余，对应的余数放进列表，然后在列表里依次判断是否重复，如果没有，则添加</p>
<h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p>概述：System包含几个有用得类字段和方法，它不能被实例化</p>
<p>常用方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static void exit(int status)</td>
<td>终止当前运行得Java虚拟机，非零表示异常终止</td>
</tr>
<tr>
<td>public static long currentTimeMillis()</td>
<td>返回当前时间（以毫秒为单位）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="概述：-2"><a href="#概述：-2" class="headerlink" title="概述："></a>概述：</h4><ul>
<li>是面向对象三大特征之一（封装，继承，多态）</li>
<li>是面向对象编程语言对客观世界的模拟，客观世界里成员变量都在影藏在对象内部的，外界无法直接操作</li>
</ul>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><ul>
<li>将类的信息隐藏在内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问</li>
<li>成员变量private，提供了对应的getXxx()/setXxx()方法</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>通过方法来控制成员变量的操作，提高了代码的安全性</li>
<li>把代码用的方法进行封装，提高了代码的复用性</li>
</ul>
<h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><h4 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class 子类名 extends 父类&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="继承中子类的特点"><a href="#继承中子类的特点" class="headerlink" title="继承中子类的特点"></a>继承中子类的特点</h4><ul>
<li>子类可以有父类的内容</li>
<li>子类还可以有自己特有的内容</li>
</ul>
<h4 id="继承中变量的访问特点（在子类方法中访问一个变量）"><a href="#继承中变量的访问特点（在子类方法中访问一个变量）" class="headerlink" title="继承中变量的访问特点（在子类方法中访问一个变量）"></a>继承中变量的访问特点（在子类方法中访问一个变量）</h4><ul>
<li>子类局部范围找</li>
<li>子类成员范围找</li>
<li>父类成员范围找</li>
<li>如果没有就报错（不考虑父亲的父亲…）</li>
</ul>
<h4 id="继承中构造方法的访问特点"><a href="#继承中构造方法的访问特点" class="headerlink" title="继承中构造方法的访问特点"></a>继承中构造方法的访问特点</h4><p>子类中所有的构造方法默认都会访问父类中的无参的构造方法，这是为什么？</p>
<ul>
<li>因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成数据的初始化</li>
<li>每一个子类构造方法的第一条语句默认都是：super()</li>
</ul>
<p>如果父类中没有无参构造方法，只有带参构造方法，该这么办呢？</p>
<ul>
<li>通过使用super关键字去显示调用父类的带参构造方法</li>
<li>在父类中自己提供一个无参构造方法（推荐自己给出无参构造方法）</li>
</ul>
<h4 id="继承中成员方法的访问特点"><a href="#继承中成员方法的访问特点" class="headerlink" title="继承中成员方法的访问特点"></a>继承中成员方法的访问特点</h4><p>通过子类对象访问一个方法</p>
<ul>
<li>子类成员范围找</li>
<li>父类成员范围找</li>
<li>如果没有就报错（不考虑父亲的父亲…）</li>
</ul>
<p>java中继承的注意事项</p>
<ul>
<li>Java中类只支持单继承，不支持多继承</li>
<li>Java中类支持多层继承</li>
</ul>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>访问本类成员变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.成员变量</span><br></pre></td></tr></table></figure>
<p>访问本类构造方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this(...)</span><br></pre></td></tr></table></figure>
<p>访问本类成员方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.成员方法(...)</span><br></pre></td></tr></table></figure>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>访问父类成员变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super.成员变量</span><br></pre></td></tr></table></figure>
<p>访问父类构造方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super(...)</span><br></pre></td></tr></table></figure>
<p>访问父类成员方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super.成员方法(...)</span><br></pre></td></tr></table></figure>
<h3 id="Override-重写"><a href="#Override-重写" class="headerlink" title="@Override(重写)"></a>@Override(重写)</h3><ul>
<li>是一个注解</li>
<li>可以帮助我们检查重写方法声明的正确性</li>
</ul>
<p>方法重写注意事项</p>
<ul>
<li>私有方法不能被重写（父类私有成员子类是不能被继承的）</li>
<li>子类方法访问权限不能更低（public&gt;默认&gt;私有）</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态中成员访问特点</p>
<ul>
<li>成员变量：编译看左边，执行看左边</li>
<li>成员方法：编译看左边，执行看右边</li>
</ul>
<p>为什么成员变量和成员方法的访问不一样？</p>
<ul>
<li>因为成员方法有重写，而成员变量没有</li>
</ul>
<p>多态的好处与弊端</p>
<ul>
<li>多态的好处：提高了编程的扩展性（具体表现：定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作）</li>
<li>多态的弊端：不能使用子类的特有功能</li>
</ul>
<p>多态中的转型</p>
<ul>
<li><p>向上转型：从子到父，父类引用指向子类对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fu a = new zi()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>向下转型：从父到子，父类引用转为子类对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zi b = (zi)a</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="抽象类-abstract"><a href="#抽象类-abstract" class="headerlink" title="抽象类(abstract)"></a>抽象类(abstract)</h3><p>抽象类的特点</p>
<ul>
<li><p>抽象类和方法必须使用abstract关键字修饰</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract class 类名&#123;&#125;</span><br><span class="line">public abstract void eat()</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</p>
</li>
<li><p>抽象类不能实例化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">抽象类如何实例化呢？参照多态的方法，通过子类对象实例化，这叫抽象类多态</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象类的子类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">要么重写抽象类中的所有抽象方法</span><br><span class="line">要么是抽象类</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>抽象类的成员特点</p>
<ul>
<li>成员变量可以是变量，也可以是常量</li>
<li>可以有构造方法，但是不能实例化，构造方法的作用是用于子类访问父类数据的初始化</li>
<li>成员方法中的抽象方法可以限定子类必须完成某些动作，而那些非抽象方法是为了提高代码的复用性</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用，而Java中的接口更多体现在对行为的抽象</p>
<h4 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h4><ul>
<li><p>接口关键字interface修饰</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface 接口名 &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类实现接口用implements表示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class 类名 implements 接口名 &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口不能实例化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态</span><br><span class="line">多态的形式：具体类多态，抽象类多态，接口多态</span><br><span class="line">多态的前提：有继承或者实现关系；有方法重写；有父（类/接口）引用指向（子/实现）类对象</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口的实现类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">要么重写接口中的所有抽象方法</span><br><span class="line">要么是抽象类</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="接口的成员特点"><a href="#接口的成员特点" class="headerlink" title="接口的成员特点"></a>接口的成员特点</h4><ul>
<li><p>成员变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">只能是常量</span><br><span class="line">默认修饰符：public static final</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接口没有构造方法，因为接口主要是对行为进行抽象的，是没有具体存在</span><br><span class="line">一个类如果没有父类，就默认继承Object类</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">只能是抽象方法</span><br><span class="line">默认修饰符：public abstract</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="类和接口的关系"><a href="#类和接口的关系" class="headerlink" title="类和接口的关系"></a>类和接口的关系</h4><ul>
<li>类和类的关系<ul>
<li>继承关系，只能单继承，但是可以多层继承</li>
</ul>
</li>
<li>类和接口的关系<ul>
<li>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</li>
</ul>
</li>
<li>接口和接口的关系<ul>
<li>继承关系，可以单继承，也可以多继承</li>
</ul>
</li>
</ul>
<h4 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h4><ul>
<li>成员区别<ul>
<li>抽象类：变量，常量，有构造方法，有抽象方法，也有非抽象方法</li>
<li>接口：常量，抽象方法</li>
</ul>
</li>
<li>关系区别<ul>
<li>类与类：继承，单继承</li>
<li>类与接口：实现，可以单实现，也可以多实现</li>
<li>接口与接口：继承，单继承，多继承</li>
</ul>
</li>
<li>设计理念区别<ul>
<li>抽象类：对类抽象，包括属性、行为</li>
<li>接口：对行为抽象，主要是行为</li>
</ul>
</li>
</ul>
<h3 id="形参和返回值"><a href="#形参和返回值" class="headerlink" title="形参和返回值"></a>形参和返回值</h3><h4 id="类名作为形参和返回值"><a href="#类名作为形参和返回值" class="headerlink" title="类名作为形参和返回值"></a>类名作为形参和返回值</h4><ul>
<li>方法的形参是类名，其实需要的是该类的对象</li>
<li>方法的返回值是类名，其实返回的是该类的对象</li>
</ul>
<h4 id="抽象类名作为形参和返回值"><a href="#抽象类名作为形参和返回值" class="headerlink" title="抽象类名作为形参和返回值"></a>抽象类名作为形参和返回值</h4><ul>
<li>方法的形参是抽象类名，其实需要的是该抽象类的子类对象</li>
<li>方法的返回值是抽象类名，其实返回的是抽象类的子类对象</li>
</ul>
<h4 id="接口名作为形参和返回值"><a href="#接口名作为形参和返回值" class="headerlink" title="接口名作为形参和返回值"></a>接口名作为形参和返回值</h4><ul>
<li>方法的形参是接口名。其实需要的是该接口的实现类对象</li>
<li>方法的返回值是接口名，其实返回的是该接口的实现类对象</li>
</ul>
<h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>本质就是文件夹，对类进行分类管理</p>
<h4 id="包得定义格式"><a href="#包得定义格式" class="headerlink" title="包得定义格式"></a>包得定义格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：package 包名；（多级包用.分开）</span><br><span class="line">范例：package com.itheima;</span><br></pre></td></tr></table></figure>
<h4 id="带包得java类编译和执行"><a href="#带包得java类编译和执行" class="headerlink" title="带包得java类编译和执行"></a>带包得java类编译和执行</h4><p>手动建包</p>
<ul>
<li><p>按照以前的格式编译Java文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动创建包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在E盘建立文件夹com，然后在com下建立文件夹itheima</span><br></pre></td></tr></table></figure>
</li>
<li><p>把calss文件放到包的最里面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把HelloWorld.class文件放到com下的itheima这个文件夹下</span><br></pre></td></tr></table></figure>
</li>
<li><p>带包执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java com.itheima.HelloWorld</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>自动建包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d. HelloWorld.java</span><br></pre></td></tr></table></figure>
<h4 id="导包的概述和使用"><a href="#导包的概述和使用" class="headerlink" title="导包的概述和使用"></a>导包的概述和使用</h4><p>使用不同包下的类的时，使用的时候要写类的全路径，写的太麻烦了。为了简化带包的操作，Java就提供了导包的功能</p>
<p>导包格式</p>
<ul>
<li>格式：import 包名</li>
<li>范例：import cn.itcast,Teacher</li>
</ul>
<h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>修饰符</th>
<th>同一个类中</th>
<th>同一个包中子类无关类</th>
<th>不同包的子类</th>
<th>不同包的无关类</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>默认</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
</div>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final关键字时最终的意思，可以修饰成员方法，成员变量，类</p>
<p>final修饰的特点</p>
<ul>
<li>修饰方法：表明该方法是最终方法，不能被重写</li>
<li>修饰变量：表明该变量时常量，不能被再次赋值</li>
<li>修饰类：表明该类是最终类，不能被继承</li>
</ul>
<p>final修饰局部变量</p>
<ul>
<li>变量是基本类型：final修饰指的是基本类型的数据值不能发生改变</li>
<li>变量是引用类型：final修饰指的是引用类型的地址值不能变，但是地址里面的内容是可以发生改变的</li>
</ul>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>static关键字是静态的意思，可以修饰成员方法，成员变量</p>
<p>static修饰的特点</p>
<ul>
<li>被类的所有对象共享（这也是我们判断是否使用静态关键字的条件）</li>
<li>可以通过类名调用（当然可以用对象名调用，推荐使用类名调用）</li>
</ul>
<p>static访问特点</p>
<p>非静态的成员方法</p>
<ul>
<li>能访问静态的成员变量</li>
<li>能访问非静态的成员变量</li>
<li>能访问静态的成员方法</li>
<li>能访问非静态的成员方法</li>
</ul>
<p>静态的成员方法（总结成一句话就是：静态成员方法只能访问静态成员）</p>
<ul>
<li>能访问静态的成员变量</li>
<li>能访问静态的成员方法</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>就是在一个类中定义一个类。举例：在一个类A中定义一个类B，类B就被称为内部类</p>
<h4 id="内部类的访问特点"><a href="#内部类的访问特点" class="headerlink" title="内部类的访问特点"></a>内部类的访问特点</h4><ul>
<li>内部类可以直接访问外部类的成员，包括私有</li>
<li>外部类要访问内部类的成员，必须创建对象</li>
</ul>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>成员内部类，外界如何创建对象使用？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：外部类名.内部类名 对象名 = 外部类名对象.内部类对象；</span><br><span class="line">范例：Outer.Inner oi = new Outer().new Inner();</span><br></pre></td></tr></table></figure>
<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>概述：局部内部类是在方法中的定义的类，所以外界是无法直接使用，需要在方法内部创建对象并使用，该类可以直接访问外部类的成员，也可以访问内部的局部变量</p>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>前提：存在一个类或接口，这里的类可以是具体类也可以是抽象类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">new 类名或接口名 ()&#123;</span><br><span class="line">	重写方法；</span><br><span class="line">&#125;；</span><br><span class="line">范列：</span><br><span class="line">new Inter()&#123;</span><br><span class="line">	public void show()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本质：是一个继承了该类或实现该接口的子类匿名对象</p>
<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>Math类的常用方法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static int abs(int a)</td>
<td>返回参数的绝对值</td>
</tr>
<tr>
<td>public static double ceil(double a)</td>
<td>返回大于或等于参数的最double值，等于一个整数</td>
</tr>
<tr>
<td>public static double floor(double a)</td>
<td>返回小于或等于参数的最大double值，等于一个整数</td>
</tr>
<tr>
<td>public static int round(float a)</td>
<td>按照四舍五入返回最接近参数的int</td>
</tr>
<tr>
<td>public static int max(int a,int b)</td>
<td>返回两个int值中的较大值</td>
</tr>
<tr>
<td>public static int min(int a,int b)</td>
<td>返回两个int值中的较小值</td>
</tr>
<tr>
<td>public static double pow(double a,double b)</td>
<td>返回a的b次幂的值</td>
</tr>
<tr>
<td>public static double random()</td>
<td>返回值为double的正值，[0.0,1.0)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>概述：Object是类层次结构的根，每个类都可以将Object作为超类。所有类都直接或间接的继承自该类</p>
<p>构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Object()</span><br></pre></td></tr></table></figure>
<p>为什么说子类的构造方法默认访问的是父类的无参构造方法？</p>
<p>以为它们的顶级父类只有无参构造方法</p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><p>方法名：public String toString()</p>
<p>作用：返回对象的字符串表示形式。结果应该是一个简明扼要的表达，容易让人阅读。建议所有子类覆盖此方法,自动生成。</p>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p>方法名：public booleaan equlas(Object obj)</p>
<p>作用：比较对象是否相等。默认比较地址，重写方法可以比较内容，推荐重写，自动生成。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul>
<li>如果有n个数据进行排序，总共需要比较n-1次</li>
<li>每一次比较完毕，下一次的比较就会少一个数据参与</li>
</ul>
<h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p>Arrays类包含用于操作数组的各种方法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static String toString(int[] a)</td>
<td>返回指定数组的内容的字符串表示形式</td>
</tr>
<tr>
<td>public static void sort(int[] a)</td>
<td>按照数字顺序排列指定数组</td>
</tr>
</tbody>
</table>
</div>
<p>工具类的设计思想：</p>
<ul>
<li>构造方法用private修饰</li>
<li>成员用public static修饰</li>
</ul>
<h3 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h3><p>概述：将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据</p>
<p>常用的操作之一：用于基本数据类型与字符串类型之间的转换</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Integer类"><a href="#Integer类" class="headerlink" title="Integer类"></a>Integer类</h4><p>概述：Integer  包装一个对象中的原始数据类型int的值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public Integer(int value)</td>
<td>根据int值创建个一integer对象（过时）</td>
</tr>
<tr>
<td>public Integer(String s)</td>
<td>根据String值创建Integer对象（过时）</td>
</tr>
<tr>
<td>public static Integer valueOf(int i)</td>
<td>返回表示指定的int值的integer实例</td>
</tr>
<tr>
<td>public static Integer valueOf(String s)</td>
<td>返回一个保存指定值的Integer对象String</td>
</tr>
</tbody>
</table>
</div>
<h4 id="int和String的相互转换"><a href="#int和String的相互转换" class="headerlink" title="int和String的相互转换"></a>int和String的相互转换</h4><p>基本类型包装类的最常见操作就是：用于基本类型和字符串之间的相互转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int转换为String</span><br><span class="line">public static String valueOf(int i)：返回int参数的字符串表示形式。该方法是String类中的方法</span><br><span class="line">String转换为int</span><br><span class="line">public static int parseInt(String s)：将字符串解析为int类型。该方法是Integer类中的方法</span><br></pre></td></tr></table></figure>
<h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h4><p>装箱：把基本数据类型转换为对应的包装类类型</p>
<p>拆箱：把包装类类型转换为对应的基本数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 100;  //自动装箱</span><br><span class="line">i += 200;         //i = i + 200; i + 200 自动拆箱；i = i + 200;是自动装箱</span><br></pre></td></tr></table></figure>
<p>注意：在使用包装类类型的时候，如果做操作，最好先判断是否为null，我们推荐的是，只要是对象，在使用前就必须进行不为null的判断</p>
<h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>常用的方法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public long getTime()</td>
<td>获取的是日期对象从1970年1月1日00:00:00到现在的毫秒</td>
</tr>
<tr>
<td>public void setTime(long time)</td>
<td>设置时间，给的是毫秒值</td>
</tr>
</tbody>
</table>
</div>
<h4 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h4><p>概述：SimpleFormat是个具体的类，用于以区域设置敏感的方式格式化和解析日期。</p>
<p>日期和时间格式由日期和时间模式字符串指定，在日期和时间模式字符串中，从‘A’到‘Z’以及从‘a’到’z’引号的字母被解释为表示日期或时间字符串的组件的模式字母</p>
<p>常用的模式字母及对应关系如下：</p>
<ul>
<li>y -年</li>
<li>M-月</li>
<li>d-日</li>
<li>H-时</li>
<li>m-分</li>
<li>s-秒</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public SimpleDateFormat()</td>
<td>构造一个SimpleDateFormat,使用默认模式和日期格式</td>
</tr>
<tr>
<td>public SimpleDateFormat(String pattern)</td>
<td>构造一个SimpleDateFormat使用给定的模式和默认的日期格式</td>
</tr>
</tbody>
</table>
</div>
<h4 id="SimpleDateFormat格式化和解析日期"><a href="#SimpleDateFormat格式化和解析日期" class="headerlink" title="SimpleDateFormat格式化和解析日期"></a>SimpleDateFormat格式化和解析日期</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式化（从Date到String）</span><br><span class="line">public final String format(Date date):将日期格式化成日期/时间字符串</span><br><span class="line">解析（从String到Date）</span><br><span class="line">public Date parse(String source):从给定字符串的开始解析文本以生成日期</span><br></pre></td></tr></table></figure>
<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>概述：Calendar为某一时刻和一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法</p>
<p>Calendar提供了一个类方法getInstance用于获取Calendar对象，其日历字段已使用当前日历和时间初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar rightNow = Calendar,gerInstance();</span><br></pre></td></tr></table></figure>
<h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public int get(int field)</td>
<td>返回给定日历字段的值</td>
</tr>
<tr>
<td>public abstract void add(int field,int amount)</td>
<td>根据日历的规矩，将指定的时间两添加或减去给定的日历字段</td>
</tr>
<tr>
<td>public final void set(int year,int mouth,int date)</td>
<td>设置当前日历的年月日</td>
</tr>
</tbody>
</table>
</div>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>概述：就是成语出现了不正常的情况</p>
<p>异常体系：</p>
<p>Throwable</p>
<ul>
<li>Error</li>
<li>Exception<ul>
<li>RuntimeException</li>
<li>非RuntimeException</li>
</ul>
</li>
</ul>
<p>Error:严重问题，不需要处理</p>
<p>Exception:称为异常类，他表示程序本身可能可以处理的问题</p>
<ul>
<li>RuntimeException：在编译是不检查的，出现问题后，需要我们回来修改代码</li>
<li>非RuntimeException：编译期就必须处理的，否则程序不能通过编译，就更不能zhengchangyunxing了</li>
</ul>
<h4 id="JVM的默认处理方案"><a href="#JVM的默认处理方案" class="headerlink" title="JVM的默认处理方案"></a>JVM的默认处理方案</h4><p>如果程序出现了问题，我们没有做任何处理，最终JVM会做出默认的处理</p>
<ul>
<li>把异常的名称，异常原因及异常出现的位置等信息输入在了控制台</li>
<li>程序停止执行</li>
</ul>
<p>异常处理之 try…catch…</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">	可能出现异常的代码;</span><br><span class="line">&#125;catch(异常类名 变量名)&#123;</span><br><span class="line">	异常的处理代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行流程：</p>
<p>程序从try里的代码开始执行，出现异常，会自动生成一个异常对象，该异常对象将被提交给java运行时系统，当java运行时系统接受到异常对象时，会到catch中找匹配的异常类，找到后进行异常的处理，执行完毕之后，程序该可以继续往下执行</p>
<h4 id="Throwable的成员方法"><a href="#Throwable的成员方法" class="headerlink" title="Throwable的成员方法"></a>Throwable的成员方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public String getMessage()</td>
<td>返回此throwable的详细消息字符串</td>
</tr>
<tr>
<td>public String toString()</td>
<td>返回此可抛出的简短描述</td>
</tr>
<tr>
<td>public void printStackTrace()</td>
<td>把异常的错误信息输出在控制台</td>
</tr>
</tbody>
</table>
</div>
<h4 id="编译时异常和运行时异常的区别"><a href="#编译时异常和运行时异常的区别" class="headerlink" title="编译时异常和运行时异常的区别"></a>编译时异常和运行时异常的区别</h4><p>java中的异常被分为两大类：编译时异常和运行时异常，也被称为受检异常和非受检异常，所有的RuntimeException类及其子类被称为运行时异常，其他的异常都是编译时异常</p>
<ul>
<li>编译时异常：必须显示处理，否则程序就会发生错误，无法通过编译</li>
<li>运行时异常：无需显示处理，也可以和编译时异常一样处理</li>
</ul>
<h4 id="异常处理之-throws"><a href="#异常处理之-throws" class="headerlink" title="异常处理之 throws"></a>异常处理之 throws</h4><p>虽然我们通过try..catch..可以对异常进行处理，但是并不是所有的情况都有权限进行异常的处理，也就是说，有些情况可能出现的异常是我们处理不了的，这个时间该怎么办呢？针对这种情况，Java提供了throws的处理方案</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throws 异常类名；</span><br></pre></td></tr></table></figure>
<p>注意：这个格式是跟在方法的括号后面的</p>
<ul>
<li>编译时异常必须要进行处理，两种处理方案：try…catch…或者throws，如果采用throws这种方案，将来谁调用谁处理</li>
<li>运行时异常可以不处理，出现问题后，需要我们回来修改代码</li>
</ul>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class 异常类名 Exception&#123;</span><br><span class="line">	无参构造方法</span><br><span class="line">	带参构造方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>范例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pubilc class ScoreExecption extends Exception&#123;</span><br><span class="line">	public ScoreException()&#123;&#125;</span><br><span class="line">	public ScoreException(String message)&#123;</span><br><span class="line">	super(message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>throws和throw的区别</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>throws</th>
<th>throw</th>
</tr>
</thead>
<tbody>
<tr>
<td>用在方法声明后面，跟的是异常类名</td>
<td>用在方法体内，跟的是异常对象名</td>
</tr>
<tr>
<td>表示抛出异常，由该方法的调用者来处理</td>
<td>表示抛出异常，有方法体内的语句处理</td>
</tr>
<tr>
<td>表示出现异常的一种可能性，并不一定会发生这些异常</td>
<td>执行throw一定抛出了某种yi’chan</td>
</tr>
</tbody>
</table>
</div>
<h3 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h3><h4 id="概述：-3"><a href="#概述：-3" class="headerlink" title="概述："></a>概述：</h4><p>是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值</p>
<p>Object类中有个方法可以获取对象的哈希值</p>
<ul>
<li>public int hashCode():返回对象的哈希值</li>
</ul>
<h4 id="对象的哈希值特点"><a href="#对象的哈希值特点" class="headerlink" title="对象的哈希值特点"></a>对象的哈希值特点</h4><ul>
<li>同一个对象多次调用hashCode()方法返回的哈希值是相同的</li>
<li>默认情况下，不同对象的哈希值是不同的，重写hashCode()方法，可以实现让不同对象的哈希值相同</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>是参数化类型，也就是说所操作的数据类型被指定为一个参数</p>
<h4 id="泛型的定义格式："><a href="#泛型的定义格式：" class="headerlink" title="泛型的定义格式："></a>泛型的定义格式：</h4><ul>
<li>&lt;类型&gt;:指定一种类型的格式。这里的类型可以看成是型参</li>
<li>&lt;类型1，类型2….&gt;:指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成 是形参</li>
<li>将来具体调用时候给定的类型可以看成是形参，并且实参的类型只能是引用数据类型</li>
</ul>
<h4 id="泛型的好处："><a href="#泛型的好处：" class="headerlink" title="泛型的好处："></a>泛型的好处：</h4><ul>
<li>把运行时期的问题提前到了编译期间</li>
<li>避免了强制类型转换</li>
</ul>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：修饰符 class 类名  &lt;类型&gt;&#123;&#125;</span><br><span class="line">范例：public class Generic&lt;T&gt;&#123;&#125;</span><br><span class="line">	此处T可以随便写为任意的标识，常见的如T,E,K,V等形式的参数常用于表示泛型</span><br></pre></td></tr></table></figure>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>定义格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：修饰符&lt;类型&gt;返回值类型 方法名(类名 变量名)&#123;&#125;</span><br><span class="line">范例：public &lt;T&gt; void show(T t)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>定义格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：修饰符 interface 接口名&lt;类型&gt;&#123;&#125;</span><br><span class="line">范例：public interface Generic&lt;T&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h4><p>为了表示各种泛型List的父类，可以使用类型通配符</p>
<ul>
<li>类型通配符：&lt;?&gt;</li>
<li>List&lt;?&gt;:表示元素类型未知的List，它的元素可以匹配任何的类型</li>
<li>这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中</li>
</ul>
<p>如果说我们不希望List&lt;?&gt;是任何泛型List的父类，只希望它代表某一类泛型List的父类，可以使用类型通配符的上限</p>
<ul>
<li>类型通配符上限：&lt;? extends 类型&gt;</li>
<li>List&lt;? extends Number&gt;:它表示的类型是Number或者其父类型</li>
</ul>
<p>除了可以指定类型通配符的上限，我们也可以指定类型通配符的下限</p>
<ul>
<li>类型通配符下限：&lt;? super 类型&gt;</li>
<li>List&lt;?super Number&gt;:它表示的类型是Number或者其父类型</li>
</ul>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>概述：可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：修饰符 返回值类型 方法名（数据类型……变量名）&#123;&#125;</span><br><span class="line">范例：public static int sum(int... a)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可变参数注意事项：</p>
<ul>
<li>这里的变量其实是一个数组</li>
<li>如果一个方法有多个参数，包含可变参数，可变参数要放在最后面</li>
</ul>
<p>可变参数的使用：</p>
<p>Arrays工具类中有个静态方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; asList(T... a)：返回由指定数组支持的固定大小的列表</span><br><span class="line">返回的集合不能做增删操作，可以做修改操作</span><br></pre></td></tr></table></figure>
<p>List接口中有一个静态方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt;List&lt;E&gt; of(E... elements):返回包含任意数量元素的不可变列表</span><br><span class="line">返回的集合不能做增删改操作</span><br></pre></td></tr></table></figure>
<p>Set接口中有一个静态方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt;Set&lt;E&gt; of(E...elements):返回一个包含任意数量元素的不可变集合</span><br><span class="line">在给元素的时候，不能给重复元素</span><br><span class="line">返回的集合不能做增删操作，没有修改的方法</span><br></pre></td></tr></table></figure>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>File：它是文件和目录路径名的抽象表示</p>
<ul>
<li>文件和目录是可以通过File封装成对象的</li>
<li>对于File而言，其封装的并不是一个正真存在的文件，仅仅是一个路径名而已，它可以是存在的，也可以是不存在的。将来是要通过具体操作把这个路径的内容转换为具体存在的</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>File(String pathname)</td>
<td>通过将给定的路径名字符串转换为抽象路径名来创建新的File实例</td>
</tr>
<tr>
<td>File(String parent,String child)</td>
<td>从父路径名字符串和子路径名字字符串创建新的File实例</td>
</tr>
<tr>
<td>File(File parent,String child)</td>
<td>从父抽象路径名和子路径名字符串创建新的File实例</td>
</tr>
</tbody>
</table>
</div>
<h4 id="创建功能"><a href="#创建功能" class="headerlink" title="创建功能"></a>创建功能</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public boolean createNewFile()</td>
<td>当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件</td>
</tr>
<tr>
<td>public boolean mkdir()</td>
<td>创建由此抽象路径名命名的目录</td>
</tr>
<tr>
<td>public boolean mkdirs()</td>
<td>创建由此抽象路径命名的目录，包括任何必需但不存在的父目录</td>
</tr>
</tbody>
</table>
</div>
<h4 id="判断和获取功能"><a href="#判断和获取功能" class="headerlink" title="判断和获取功能"></a>判断和获取功能</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说名</th>
</tr>
</thead>
<tbody>
<tr>
<td>public boolean isDirectory()</td>
<td>测试此抽象路径名表示的File是否为目录</td>
</tr>
<tr>
<td>public boolean isFile()</td>
<td>测试此抽象路径名表示的File是否为文件</td>
</tr>
<tr>
<td>pubilc boolean exists()</td>
<td>测试此抽象路径名表示的File是否存在</td>
</tr>
<tr>
<td>public String getAbsolutePath()</td>
<td>返回此抽象路径名的绝对路径名字符串</td>
</tr>
<tr>
<td>public String getPath()</td>
<td>将此抽象路径名转换为路径名字符串</td>
</tr>
<tr>
<td>public String getName()</td>
<td>返回由此抽象路径名表示的文件或目录的名称</td>
</tr>
<tr>
<td>public String[] list()</td>
<td>返回此路径名表示的目录中的文件和目录的名称字符串数组</td>
</tr>
<tr>
<td>public File[] listFiles()</td>
<td>返回此抽象路径名表示的目录中文件和目录的File对象数组</td>
</tr>
</tbody>
</table>
</div>
<h4 id="File类删除功能"><a href="#File类删除功能" class="headerlink" title="File类删除功能"></a>File类删除功能</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public boolean delete()</td>
<td>删除由此抽象路径名表示的文件或目录</td>
</tr>
</tbody>
</table>
</div>
<p>绝对路径和相对路径的区别</p>
<ul>
<li>绝对路径：完整的路径名，不需要任何其他信息就可以定位它所表示的文件。例如：E://itcast//java.txt</li>
<li>相对路径：必须使用取自其他路径名的信息进行解释。例如：myFile//java.txt</li>
</ul>
<p>删除目录时的注意事项：</p>
<ul>
<li>如果一个目录中有内容（目录，文件），不能直接删除，应该先删除目录中的内容，最后才能删除目录</li>
</ul>
<h3 id="特殊操作流"><a href="#特殊操作流" class="headerlink" title="特殊操作流"></a>特殊操作流</h3><h4 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h4><p>System类中有两个静态的成员变量：</p>
<ul>
<li>public static final InputStream in:标准输入流。通常该流对应于键盘输入或主机环境或用户指定的另一个输入源</li>
<li>public static final PrintStream out:标准输出流。通常该流对应于显示输出或由主机环境或用户指定的另个输出目标</li>
</ul>
<p>自己实现键盘录入数据：</p>
<ul>
<li>BufferedReader br = new Bufferer(new InputStreamReader(System.in));</li>
</ul>
<p>写起来太麻烦了，java就提供了一个类实现键盘录入</p>
<ul>
<li>Scanner sc = new Scanner(System.in);</li>
</ul>
<p>输出语句的本质：是一个标准的输出流</p>
<ul>
<li>PrintStream ps = System.out;</li>
<li>PrintStream类有的方法，System.out都可以使用</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>概述：是正在运行的程序</p>
<ul>
<li>是系统进行资源分配和调用的独立单位</li>
<li>每一个进程都有它自己的内存空间和系统资源</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>概叙：</p>
<p>是进程中的单个顺序控制流，是一条执行路径</p>
<ul>
<li>单线程：一个进程如果只有一条执行路径，则称为单线程程序</li>
<li>多线程：一个进程如果有多条执行路径，则称为多线程程序</li>
</ul>
<h4 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h4><p>方法一：继承Thread类</p>
<ul>
<li>定义一个类MyThread继承Thread类</li>
<li>在MyThread类中重写run()方法</li>
<li>创建MyThread类对象</li>
<li>启动线程</li>
</ul>
<p>方法二：实现Runnable接口</p>
<ul>
<li>定义一个类MyRunable实现Runnable接口</li>
<li>在MyRunnable类中重写run()方法</li>
<li>创建MyRunnable类的对象</li>
<li>创建Thread类的对象，把MyRunnable对象作为构造方法的参数</li>
<li>启动线程</li>
</ul>
<p>多线程的实现方案有两种</p>
<ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
</ul>
<p>相比继承Thread类，实现Runnable接口的好处</p>
<ul>
<li>避免了Java单继承的局限性</li>
<li>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想</li>
</ul>
<p>两个小问题</p>
<ul>
<li><p>为什么要重写run()方法？</p>
<p>因为run()用来封装被线程执行的代码</p>
</li>
<li><p>run()方法和statrt()方法的区别</p>
<p>run():封装线程执的代码，直接调用，相当于普通方法的调用</p>
<p>start():启动线程，然后由JVM调用此线程的run()方法</p>
</li>
</ul>
<h4 id="设置和获取线程名称"><a href="#设置和获取线程名称" class="headerlink" title="设置和获取线程名称"></a>设置和获取线程名称</h4><p>Thread类中设置和获取线程名称的方法</p>
<ul>
<li>void setName(String name):将此线程的名称更改为等于参数name</li>
<li>String getName():返回此线程的名称</li>
</ul>
<p>如何获取main()方法所在的线程的名称？</p>
<ul>
<li>public static Thread currentThread()返回对当前正在执行的线程对象的引用</li>
</ul>
<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>线程有两种调度模型</p>
<ul>
<li>分时间模型：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片</li>
<li>抢占式调度模型：优先让优先级高的线程使用cpu，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的cpu时间片相对多一些</li>
</ul>
<p>java使用的是抢占式调都模型</p>
<p>假如计算机只有一个CPU，那么CPU在某个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁强到CPU的使用权是不一样的</p>
<p>Thread类中设置和获取线程优先级的方法</p>
<ul>
<li>public final int getPriority():返回此线程的优先级</li>
<li>public final void setPriority(int newPriority):更改此线程的优先级</li>
</ul>
<p>线程默认优先级是5；线程优先级的范围是：1-10</p>
<p>线程优先级高级仅仅表示获取的CPU时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到你想要的效果</p>
<h4 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static void sleep(long millis)</td>
<td>使当前正在执行的线程停留（暂停执行）指定的毫秒数</td>
</tr>
<tr>
<td>void join()</td>
<td>等待这个线程死亡</td>
</tr>
<tr>
<td>void setDaemon(boolean on)</td>
<td>将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出</td>
</tr>
</tbody>
</table>
</div>
<h4 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h4><p>要点：</p>
<ul>
<li>由新建，就绪，运行或堵塞，死亡组成</li>
<li>start()使线程具有执行资格</li>
<li>抢到CPU的线程具有执行权</li>
<li>sleep()可以堵塞线程</li>
</ul>
<h4 id="数据安全问题"><a href="#数据安全问题" class="headerlink" title="数据安全问题"></a>数据安全问题</h4><p>为什么出现问题？（这也就是判断多线程是否会出现数据安全问题的标准）</p>
<ul>
<li>是否是多线程环境</li>
<li>是否有共享数据</li>
<li>是否有多条语句操作共享数据</li>
</ul>
<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><p>锁定多条语句操作共享数据，可以使用同步代码块实现</p>
<ul>
<li><p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronrized(任意对象)&#123;</span><br><span class="line">	多条语句操作共享数据的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>synchronized(任意对象):就相当于给代码加锁了，任意对象就可以看成是一把锁</p>
</li>
</ul>
<p>同步的好处和弊端</p>
<ul>
<li>好处：解决了多线程的数据安全问题</li>
<li>弊端：当线程很多时，因为每个线程都会去判断同步上锁，这是很耗费资源的，无形中会降低程序的运行效率</li>
</ul>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>同步方法：就是把synchronized关键字加到方法上</p>
<ul>
<li><p>格式：</p>
<p>修饰符 synchronized 返回值类型 方法名（方法参数）{}</p>
</li>
</ul>
<p>同步方法的锁对象时什么呢？</p>
<ul>
<li>this</li>
</ul>
<p>同步静态方法：就是把synchronized</p>
<ul>
<li><p>格式：</p>
<p>修饰符 static synchronized 返回值类型 方法名（方法参数）{}</p>
</li>
</ul>
<p>同步静态方法的锁对象时什么呢？</p>
<ul>
<li>类名.class</li>
</ul>
<h4 id="线程安全的类"><a href="#线程安全的类" class="headerlink" title="线程安全的类"></a>线程安全的类</h4><p>StringBuffer</p>
<ul>
<li>线程安全，可变的字符序列</li>
<li>从版本JDK5开始，被StringBuilder替代。通常应该使用StringBuilder类，因为它支持所有相同的操作，但它更快，因为它不执行同步</li>
</ul>
<p>Vector</p>
<ul>
<li>从Java2平台v1.2开始，该类改进了List接口，使其成为Java CollectionsFramework的成员，与新的集合实现不同，Vector被同步。如果不需要线程安全的实现，建议使用ArrayList代替Vertor</li>
</ul>
<p>Hashtable</p>
<ul>
<li>给类实现了一个哈希表，它将键映射到值。任何非null对象都可以用作键或者值</li>
<li>从java2平台v1.2开始，该类进行了改进，实现了Map接口，使其成为Java Collections Framework的成员。与新的集合实现不同，Hashtable被同步。如果不需要线程安全的实现，建议使用HashMap替代Hashtable</li>
</ul>
<h4 id="Look锁"><a href="#Look锁" class="headerlink" title="Look锁"></a>Look锁</h4><p>虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到哪里加了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock</p>
<p>Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作</p>
<p>Lock中提供了获得锁和释放锁的方法</p>
<ul>
<li>void lock():获得锁</li>
<li>void unlock():释放锁</li>
</ul>
<p>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化</p>
<p>ReentrantLock的构造方法</p>
<ul>
<li>ReentrantLock():创建一个ReentrantLock的实例</li>
</ul>
<h4 id="生产者消费者模式概述"><a href="#生产者消费者模式概述" class="headerlink" title="生产者消费者模式概述"></a>生产者消费者模式概述</h4><p>为了体现生产和消费过程中的等待和唤醒，Java就提供了几个方法供我们使用，值几个方法在Object类中</p>
<p>Object类的等待和唤醒方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void wait()</td>
<td>导致当前线程等待，直到另一个线程调用对象的notify()方法或者notifyAll()方法</td>
</tr>
<tr>
<td>void notify()</td>
<td>唤醒正在等待对象监视器的单个线程</td>
</tr>
<tr>
<td>void notifyAll()</td>
<td>唤醒正在等待对象监视器的所有线程</td>
</tr>
</tbody>
</table>
</div>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><h4 id="字符串的分割"><a href="#字符串的分割" class="headerlink" title="字符串的分割"></a>字符串的分割</h4><p>Java 提供了多种方法来分割字符串。最常用的是使用 <code>String.split()</code> 方法。</p>
<p>以下是一些示例:</p>
<p>使用空格分割字符串:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">String[] words = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">// words 数组包含 [&quot;Hello&quot;, &quot;World&quot;]</span></span><br></pre></td></tr></table></figure>
<p>使用逗号分割字符串:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;apple,banana,cherry&quot;</span>;</span><br><span class="line">String[] fruits = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="comment">// fruits 数组包含 [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]</span></span><br></pre></td></tr></table></figure>
<p>使用正则表达式分割字符串:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Java-Python-C++&quot;</span>;</span><br><span class="line">String[] languages = str.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="comment">// languages 数组包含 [&quot;Java&quot;, &quot;Python&quot;, &quot;C++&quot;]</span></span><br></pre></td></tr></table></figure>
<p>限制分割的最大数量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;one two three four&quot;</span>;</span><br><span class="line">String[] parts = str.split(<span class="string">&quot; &quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// parts 数组包含 [&quot;one&quot;, &quot;two three four&quot;]</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中,<code>str.split(&quot; &quot;, 2)</code> 表示最多分割成 2 个部分,即第一个空格之前的部分和剩余的部分。</p>
<p>总之,<code>String.split()</code> 方法提供了很大的灵活性,可以根据需要使用不同的分隔符或正则表达式来分割字符串。这是 Java 中非常常用的字符串操作技巧。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yufusir.github.io">愚夫</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yufusir.github.io/posts/4454963.html">https://yufusir.github.io/posts/4454963.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yufusir.github.io" target="_blank">孤城一豪&blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/66b21119d9c307b7e9f5da19.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/c0de5885.html" title="黑马程序员python自学笔记，超详细（内置环境配置与编译器的下载）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66c37bd2d9c307b7e97fe0c7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">黑马程序员python自学笔记，超详细（内置环境配置与编译器的下载）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/ca348d9f.html" title="黑马程序员C++自学笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66c1d7f6d9c307b7e92306a3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-19</div><div class="title">黑马程序员C++自学笔记</div></div></a></div><div><a href="/posts/c0de5885.html" title="黑马程序员python自学笔记，超详细（内置环境配置与编译器的下载）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66c37bd2d9c307b7e97fe0c7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-09</div><div class="title">黑马程序员python自学笔记，超详细（内置环境配置与编译器的下载）</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">愚夫</div><div class="author-info__description">海的那边 是自由</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yufusir/yufusir.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站的文章都是本人在学习过程中的自制笔记，分享于此，希望大家喜欢。若有问题可以通过qq：750603895 联系本人</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%BC%80%E5%A7%8B"><span class="toc-number">1.</span> <span class="toc-text">java学习的开始</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA"><span class="toc-number">1.1.</span> <span class="toc-text">环境的搭建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84DOS%E5%91%BD%E4%BB%A4%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">常用的DOS命令：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HelloWorld%E6%A1%88%E4%BE%8B"><span class="toc-number">1.3.</span> <span class="toc-text">HelloWorld案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E7%9A%84%E4%B8%8B%E8%BD%BD%EF%BC%9A"><span class="toc-number">1.4.</span> <span class="toc-text">编译工具的下载：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.2.</span> <span class="toc-text">构造方法的注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">什么是对象：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%EF%BC%9A"><span class="toc-number">3.2.</span> <span class="toc-text">什么是类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">3.3.</span> <span class="toc-text">类的特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">3.4.</span> <span class="toc-text">什么是对象的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">3.5.</span> <span class="toc-text">什么是对象的行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.6.</span> <span class="toc-text">类和对象的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-number">4.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.1.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95-E-e%E6%98%AF%E5%85%83%E7%B4%A0%E7%9A%84%E6%84%8F%E6%80%9D"><span class="toc-number">4.2.</span> <span class="toc-text">添加方法(E e是元素的意思)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList%E9%9B%86%E5%90%88"><span class="toc-number">5.</span> <span class="toc-text">LinkedList集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%9C%89%E5%8A%9F%E8%83%BD%EF%BC%88%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">特有功能（方法）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashSet%E9%9B%86%E5%90%88"><span class="toc-number">6.</span> <span class="toc-text">LinkedHashSet集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">6.1.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E9%9B%86%E5%90%88"><span class="toc-number">7.</span> <span class="toc-text">Set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%EF%BC%9A"><span class="toc-number">7.1.</span> <span class="toc-text">概述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">7.2.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet-%E9%9B%86%E5%90%88"><span class="toc-number">7.3.</span> <span class="toc-text">HashSet()集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeSet%E9%9B%86%E5%90%88"><span class="toc-number">7.4.</span> <span class="toc-text">TreeSet集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8FComparable%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.5.</span> <span class="toc-text">自然排序Comparable的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%99%A8%E6%8E%92%E5%BA%8FComparator%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.6.</span> <span class="toc-text">比较器排序Comparator的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection"><span class="toc-number">8.</span> <span class="toc-text">Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Collection%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%EF%BC%9A"><span class="toc-number">8.1.</span> <span class="toc-text">Collection集合概述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BACollection%E9%9B%86%E5%90%88%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.2.</span> <span class="toc-text">创建Collection集合的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Collection%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">8.4.</span> <span class="toc-text">Collection集合的遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collections%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">Collections类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">9.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">9.2.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E9%9B%86%E5%90%88"><span class="toc-number">10.</span> <span class="toc-text">List集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#List%E9%9B%86%E5%90%88%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">10.1.</span> <span class="toc-text">List集合特有方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8-ConcurrentModificationException"><span class="toc-number">10.2.</span> <span class="toc-text">并发修改异常(ConcurrentModificationException)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ListIterator-%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.3.</span> <span class="toc-text">ListIterator(列表迭代器)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List%E9%9B%86%E5%90%88%E5%AD%90%E7%B1%BB%E7%89%B9%E7%82%B9"><span class="toc-number">10.4.</span> <span class="toc-text">List集合子类特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88"><span class="toc-number">11.</span> <span class="toc-text">Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">11.1.</span> <span class="toc-text">基本方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD"><span class="toc-number">11.2.</span> <span class="toc-text">获取功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">12.</span> <span class="toc-text">增强for循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">12.1.</span> <span class="toc-text">作用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-number">12.2.</span> <span class="toc-text">格式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">13.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%EF%BC%9A-1"><span class="toc-number">13.1.</span> <span class="toc-text">概述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88"><span class="toc-number">13.2.</span> <span class="toc-text">常见数据结构之栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97"><span class="toc-number">13.3.</span> <span class="toc-text">常见数据结构之队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84"><span class="toc-number">13.4.</span> <span class="toc-text">常见数据结构之数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8"><span class="toc-number">13.5.</span> <span class="toc-text">常见数据结构之链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">13.6.</span> <span class="toc-text">常见数据结构之哈希表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System%E7%B1%BB"><span class="toc-number">14.</span> <span class="toc-text">System类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">15.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%EF%BC%9A-2"><span class="toc-number">15.1.</span> <span class="toc-text">概述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%88%99"><span class="toc-number">15.2.</span> <span class="toc-text">原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">15.3.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extends"><span class="toc-number">16.</span> <span class="toc-text">extends</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">16.1.</span> <span class="toc-text">使用格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E5%AD%90%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">16.2.</span> <span class="toc-text">继承中子类的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9%EF%BC%88%E5%9C%A8%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95%E4%B8%AD%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%EF%BC%89"><span class="toc-number">16.3.</span> <span class="toc-text">继承中变量的访问特点（在子类方法中访问一个变量）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">16.4.</span> <span class="toc-text">继承中构造方法的访问特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">16.5.</span> <span class="toc-text">继承中成员方法的访问特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-number">17.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super"><span class="toc-number">18.</span> <span class="toc-text">super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Override-%E9%87%8D%E5%86%99"><span class="toc-number">19.</span> <span class="toc-text">@Override(重写)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">20.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-abstract"><span class="toc-number">21.</span> <span class="toc-text">抽象类(abstract)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">22.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">22.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">22.2.</span> <span class="toc-text">接口的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%88%90%E5%91%98%E7%89%B9%E7%82%B9"><span class="toc-number">22.3.</span> <span class="toc-text">接口的成员特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">22.4.</span> <span class="toc-text">类和接口的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">22.5.</span> <span class="toc-text">抽象类和接口的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">23.</span> <span class="toc-text">形参和返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">23.1.</span> <span class="toc-text">类名作为形参和返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">23.2.</span> <span class="toc-text">抽象类名作为形参和返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">23.3.</span> <span class="toc-text">接口名作为形参和返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#package"><span class="toc-number">24.</span> <span class="toc-text">package</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">24.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E5%BE%97%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F"><span class="toc-number">24.2.</span> <span class="toc-text">包得定义格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%8C%85%E5%BE%97java%E7%B1%BB%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C"><span class="toc-number">24.3.</span> <span class="toc-text">带包得java类编译和执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%8C%85%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">24.4.</span> <span class="toc-text">导包的概述和使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">25.</span> <span class="toc-text">权限修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#final"><span class="toc-number">25.1.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static"><span class="toc-number">25.2.</span> <span class="toc-text">static</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">26.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">26.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">26.2.</span> <span class="toc-text">内部类的访问特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">26.3.</span> <span class="toc-text">成员内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">26.4.</span> <span class="toc-text">局部内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">26.5.</span> <span class="toc-text">匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math%E7%B1%BB"><span class="toc-number">27.</span> <span class="toc-text">Math类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E7%B1%BB"><span class="toc-number">28.</span> <span class="toc-text">Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#toString-NaN"><span class="toc-number">28.1.</span> <span class="toc-text">toString</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#equals"><span class="toc-number">28.2.</span> <span class="toc-text">equals()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">29.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays%E7%B1%BB"><span class="toc-number">30.</span> <span class="toc-text">Arrays类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">31.</span> <span class="toc-text">基本类型包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Integer%E7%B1%BB"><span class="toc-number">31.1.</span> <span class="toc-text">Integer类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int%E5%92%8CString%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">31.2.</span> <span class="toc-text">int和String的相互转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="toc-number">31.3.</span> <span class="toc-text">自动装箱和拆箱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Date%E7%B1%BB"><span class="toc-number">32.</span> <span class="toc-text">Date类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SimpleDateFormat%E7%B1%BB"><span class="toc-number">32.1.</span> <span class="toc-text">SimpleDateFormat类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SimpleDateFormat%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%92%8C%E8%A7%A3%E6%9E%90%E6%97%A5%E6%9C%9F"><span class="toc-number">32.2.</span> <span class="toc-text">SimpleDateFormat格式化和解析日期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calendar%E7%B1%BB"><span class="toc-number">33.</span> <span class="toc-text">Calendar类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-number">33.1.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">34.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM%E7%9A%84%E9%BB%98%E8%AE%A4%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88"><span class="toc-number">34.1.</span> <span class="toc-text">JVM的默认处理方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Throwable%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">34.2.</span> <span class="toc-text">Throwable的成员方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">34.3.</span> <span class="toc-text">编译时异常和运行时异常的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B9%8B-throws"><span class="toc-number">34.4.</span> <span class="toc-text">异常处理之 throws</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">34.5.</span> <span class="toc-text">自定义异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%80%BC"><span class="toc-number">35.</span> <span class="toc-text">哈希值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%EF%BC%9A-3"><span class="toc-number">35.1.</span> <span class="toc-text">概述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC%E7%89%B9%E7%82%B9"><span class="toc-number">35.2.</span> <span class="toc-text">对象的哈希值特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">36.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E8%B4%A8"><span class="toc-number">36.1.</span> <span class="toc-text">本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-number">36.2.</span> <span class="toc-text">泛型的定义格式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9A"><span class="toc-number">36.3.</span> <span class="toc-text">泛型的好处：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">36.4.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">36.5.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">36.6.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">36.7.</span> <span class="toc-text">类型通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">36.8.</span> <span class="toc-text">可变参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File%E7%B1%BB"><span class="toc-number">37.</span> <span class="toc-text">File类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">37.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%8A%9F%E8%83%BD"><span class="toc-number">37.2.</span> <span class="toc-text">创建功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%92%8C%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD"><span class="toc-number">37.3.</span> <span class="toc-text">判断和获取功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#File%E7%B1%BB%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD"><span class="toc-number">37.4.</span> <span class="toc-text">File类删除功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C%E6%B5%81"><span class="toc-number">38.</span> <span class="toc-text">特殊操作流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">38.1.</span> <span class="toc-text">标准输入输出流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">39.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">40.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">40.1.</span> <span class="toc-text">多线程的实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0"><span class="toc-number">40.2.</span> <span class="toc-text">设置和获取线程名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">40.3.</span> <span class="toc-text">线程调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">40.4.</span> <span class="toc-text">线程控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">40.5.</span> <span class="toc-text">线程生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">40.6.</span> <span class="toc-text">数据安全问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">40.7.</span> <span class="toc-text">同步代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">40.8.</span> <span class="toc-text">同步方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">40.9.</span> <span class="toc-text">线程安全的类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Look%E9%94%81"><span class="toc-number">40.10.</span> <span class="toc-text">Look锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="toc-number">40.11.</span> <span class="toc-text">生产者消费者模式概述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">41.</span> <span class="toc-text">数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%86%E5%89%B2"><span class="toc-number">41.1.</span> <span class="toc-text">字符串的分割</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/a1d1e9f8.html" title="光速入门linux，把玩linux的常用命令行"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6736203bd29ded1a8cd6e2c7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="光速入门linux，把玩linux的常用命令行"/></a><div class="content"><a class="title" href="/posts/a1d1e9f8.html" title="光速入门linux，把玩linux的常用命令行">光速入门linux，把玩linux的常用命令行</a><time datetime="2024-11-14T16:00:00.000Z" title="发表于 2024-11-15 00:00:00">2024-11-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/aee26bdb.html" title="图形化界面管理学生系统（附有详细解析）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/672a25a3d29ded1a8ce0ac80.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图形化界面管理学生系统（附有详细解析）"/></a><div class="content"><a class="title" href="/posts/aee26bdb.html" title="图形化界面管理学生系统（附有详细解析）">图形化界面管理学生系统（附有详细解析）</a><time datetime="2024-11-04T16:00:00.000Z" title="发表于 2024-11-05 00:00:00">2024-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/df727d95.html" title="快速熟悉git操作，实现远程开发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66fce1c5f21886ccc0c51a4b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="快速熟悉git操作，实现远程开发"/></a><div class="content"><a class="title" href="/posts/df727d95.html" title="快速熟悉git操作，实现远程开发">快速熟悉git操作，实现远程开发</a><time datetime="2024-10-01T16:00:00.000Z" title="发表于 2024-10-02 00:00:00">2024-10-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/be51962c.html" title="Mysql快速入门，熟悉基本命令（在kali中使用）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66eef52ef21886ccc0abf407.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mysql快速入门，熟悉基本命令（在kali中使用）"/></a><div class="content"><a class="title" href="/posts/be51962c.html" title="Mysql快速入门，熟悉基本命令（在kali中使用）">Mysql快速入门，熟悉基本命令（在kali中使用）</a><time datetime="2024-09-21T16:00:00.000Z" title="发表于 2024-09-22 00:00:00">2024-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8a3bc19b.html" title="爬虫项目：爬取中国大学的排名并进行可视化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66ec432af21886ccc0262e8b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="爬虫项目：爬取中国大学的排名并进行可视化"/></a><div class="content"><a class="title" href="/posts/8a3bc19b.html" title="爬虫项目：爬取中国大学的排名并进行可视化">爬虫项目：爬取中国大学的排名并进行可视化</a><time datetime="2024-09-18T16:00:00.000Z" title="发表于 2024-09-19 00:00:00">2024-09-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By 愚夫</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><script>(() => {
  const disqus_config = function () {
    this.page.url = 'https://yufusir.github.io/posts/4454963.html'
    this.page.identifier = '/posts/4454963.html'
    this.page.title = '黑马程序员java自学笔记（包括Java环境配置与IDEA的下载地址）'
  }

  const disqusReset = () => {
    window.DISQUS && window.DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addGlobalFn('themeChange', disqusReset, 'disqus')

  const loadDisqus = () =>{
    if (window.DISQUS) disqusReset()
    else {
      const script = document.createElement('script')
      script.src = 'https://.disqus.com/embed.js'
      script.setAttribute('data-timestamp', +new Date())
      document.head.appendChild(script)
    }
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqus-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=&api_key=&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()

      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if ('Valine' === 'Disqus' || !true) {
    if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
    else {
      loadDisqus()
      GLOBAL_CONFIG_SITE.isPost && getCount()
    }
  } else {
    window.loadOtherComment = loadDisqus
  }
})()</script></div><div class="aplayer no-destroy" data-id="6845007410" data-server="netease" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script async src="/js/ali_font.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>